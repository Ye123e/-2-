#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
病毒隔离和清除功能模块
提供安全的恶意软件隔离、清除和恢复机制
"""

import os
import shutil
import json
import hashlib
import zipfile
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
from pathlib import Path
from dataclasses import dataclass, field

from ..models import ThreatLevel, MalwareInfo, TaskStatus
from ..utils.logger import LoggerMixin
from .device_manager import DeviceManager


@dataclass
class QuarantineItem:
    """隔离项目"""
    quarantine_id: str
    original_path: str
    quarantine_path: str
    malware_info: Dict[str, Any]
    quarantine_time: datetime
    restore_available: bool = True
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'quarantine_id': self.quarantine_id,
            'original_path': self.original_path,
            'quarantine_path': self.quarantine_path,
            'malware_info': self.malware_info,
            'quarantine_time': self.quarantine_time.isoformat(),
            'restore_available': self.restore_available,
            'metadata': self.metadata
        }


@dataclass  
class RemovalOperation:
    """清除操作记录"""
    operation_id: str
    target_type: str  # 'file', 'application', 'process'
    target_identifier: str
    removal_method: str  # 'uninstall', 'delete', 'kill'
    timestamp: datetime
    success: bool
    backup_path: Optional[str] = None
    error_message: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'operation_id': self.operation_id,
            'target_type': self.target_type,
            'target_identifier': self.target_identifier,
            'removal_method': self.removal_method,
            'timestamp': self.timestamp.isoformat(),
            'success': self.success,
            'backup_path': self.backup_path,
            'error_message': self.error_message
        }


class QuarantineManager(LoggerMixin):
    """隔离管理器"""
    
    def __init__(self, quarantine_root: str = "data/quarantine"):
        """
        初始化隔离管理器
        
        Args:
            quarantine_root: 隔离文件存储根目录
        """
        self.quarantine_root = Path(quarantine_root)
        self.quarantine_root.mkdir(parents=True, exist_ok=True)
        
        # 隔离区域结构
        self.quarantine_files = self.quarantine_root / "files"
        self.quarantine_apps = self.quarantine_root / "applications" 
        self.quarantine_metadata = self.quarantine_root / "metadata"
        
        for path in [self.quarantine_files, self.quarantine_apps, self.quarantine_metadata]:
            path.mkdir(exist_ok=True)
        
        # 隔离记录
        self.quarantine_db = self.quarantine_metadata / "quarantine.json"
        self.quarantined_items: Dict[str, QuarantineItem] = {}
        
        # 配置
        self.max_quarantine_age = 30  # 天
        self.max_quarantine_size = 1024 * 1024 * 1024  # 1GB
        
        self._load_quarantine_db()
    
    def _load_quarantine_db(self):
        """加载隔离数据库"""
        try:
            if self.quarantine_db.exists():
                with open(self.quarantine_db, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    
                for item_id, item_data in data.items():
                    self.quarantined_items[item_id] = QuarantineItem(
                        quarantine_id=item_data['quarantine_id'],
                        original_path=item_data['original_path'],
                        quarantine_path=item_data['quarantine_path'],
                        malware_info=item_data['malware_info'],
                        quarantine_time=datetime.fromisoformat(item_data['quarantine_time']),
                        restore_available=item_data.get('restore_available', True),
                        metadata=item_data.get('metadata', {})
                    )
                    
            self.logger.info(f"加载隔离记录: {len(self.quarantined_items)} 个项目")
            
        except Exception as e:
            self.logger.error(f"加载隔离数据库失败: {e}")
    
    def _save_quarantine_db(self):
        """保存隔离数据库"""
        try:
            data = {}
            for item_id, item in self.quarantined_items.items():
                data[item_id] = item.to_dict()
            
            with open(self.quarantine_db, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
                
        except Exception as e:
            self.logger.error(f"保存隔离数据库失败: {e}")
    
    def quarantine_file(self, file_path: str, malware_info: Dict[str, Any]) -> Optional[str]:
        """
        隔离文件
        
        Args:
            file_path: 要隔离的文件路径
            malware_info: 恶意软件信息
            
        Returns:
            隔离ID，失败时返回None
        """
        try:
            if not os.path.exists(file_path):
                self.logger.error(f"文件不存在: {file_path}")
                return None
            
            # 生成隔离ID
            file_hash = self._calculate_file_hash(file_path)
            quarantine_id = f"file_{file_hash}_{int(datetime.now().timestamp())}"
            
            # 创建隔离路径
            quarantine_path = self.quarantine_files / f"{quarantine_id}.quarantine"
            
            # 压缩并加密文件
            if self._secure_move_file(file_path, quarantine_path):
                # 记录隔离信息
                quarantine_item = QuarantineItem(
                    quarantine_id=quarantine_id,
                    original_path=file_path,
                    quarantine_path=str(quarantine_path),
                    malware_info=malware_info,
                    quarantine_time=datetime.now(),
                    metadata={
                        'file_size': os.path.getsize(quarantine_path),
                        'file_hash': file_hash,
                        'quarantine_method': 'file_move'
                    }
                )
                
                self.quarantined_items[quarantine_id] = quarantine_item
                self._save_quarantine_db()
                
                self.logger.info(f"文件已隔离: {file_path} -> {quarantine_id}")
                return quarantine_id
            
        except Exception as e:
            self.logger.error(f"文件隔离失败: {e}")
        
        return None
    
    def quarantine_application(self, device_id: str, package_name: str, 
                             malware_info: Dict[str, Any]) -> Optional[str]:
        """
        隔离应用程序（通过禁用实现）
        
        Args:
            device_id: 设备ID
            package_name: 应用包名
            malware_info: 恶意软件信息
            
        Returns:
            隔离ID，失败时返回None
        """
        try:
            # 生成隔离ID
            quarantine_id = f"app_{package_name}_{int(datetime.now().timestamp())}"
            
            # 记录隔离信息（应用隔离不移动文件，只记录状态）
            quarantine_item = QuarantineItem(
                quarantine_id=quarantine_id,
                original_path=f"android://app/{package_name}",
                quarantine_path="",  # 应用隔离无需物理路径
                malware_info=malware_info,
                quarantine_time=datetime.now(),
                metadata={
                    'device_id': device_id,
                    'package_name': package_name,
                    'quarantine_method': 'app_disable',
                    'disabled': True
                }
            )
            
            self.quarantined_items[quarantine_id] = quarantine_item
            self._save_quarantine_db()
            
            self.logger.info(f"应用已标记为隔离: {package_name} -> {quarantine_id}")
            return quarantine_id
            
        except Exception as e:
            self.logger.error(f"应用隔离失败: {e}")
            return None
    
    def restore_quarantined_item(self, quarantine_id: str) -> bool:
        """
        恢复隔离项目
        
        Args:
            quarantine_id: 隔离ID
            
        Returns:
            恢复是否成功
        """
        try:
            if quarantine_id not in self.quarantined_items:
                self.logger.error(f"隔离项目不存在: {quarantine_id}")
                return False
            
            item = self.quarantined_items[quarantine_id]
            
            if not item.restore_available:
                self.logger.error(f"隔离项目不支持恢复: {quarantine_id}")
                return False
            
            quarantine_method = item.metadata.get('quarantine_method')
            
            if quarantine_method == 'file_move':
                # 恢复文件
                if self._restore_quarantined_file(item):
                    del self.quarantined_items[quarantine_id]
                    self._save_quarantine_db()
                    self.logger.info(f"文件恢复成功: {quarantine_id}")
                    return True
            
            elif quarantine_method == 'app_disable':
                # 恢复应用（标记为已恢复）
                item.metadata['restored'] = True
                item.restore_available = False
                self._save_quarantine_db()
                self.logger.info(f"应用恢复标记成功: {quarantine_id}")
                return True
            
        except Exception as e:
            self.logger.error(f"恢复隔离项目失败: {e}")
        
        return False
    
    def _secure_move_file(self, source: str, destination: Path) -> bool:
        """安全移动文件到隔离区"""
        try:
            # 创建压缩包
            with zipfile.ZipFile(destination, 'w', zipfile.ZIP_DEFLATED) as zf:
                zf.write(source, os.path.basename(source))
                
                # 添加元数据
                metadata = {
                    'original_path': source,
                    'quarantine_time': datetime.now().isoformat(),
                    'file_hash': self._calculate_file_hash(source)
                }
                zf.writestr('metadata.json', json.dumps(metadata, indent=2))
            
            # 删除原文件
            os.remove(source)
            return True
            
        except Exception as e:
            self.logger.error(f"安全移动文件失败: {e}")
            return False
    
    def _restore_quarantined_file(self, item: QuarantineItem) -> bool:
        """恢复隔离的文件"""
        try:
            quarantine_path = Path(item.quarantine_path)
            if not quarantine_path.exists():
                self.logger.error(f"隔离文件不存在: {quarantine_path}")
                return False
            
            # 解压文件
            with zipfile.ZipFile(quarantine_path, 'r') as zf:
                # 提取原始文件
                file_names = [name for name in zf.namelist() if name != 'metadata.json']
                if not file_names:
                    return False
                
                original_file = file_names[0]
                extracted_data = zf.read(original_file)
                
                # 恢复到原始位置
                os.makedirs(os.path.dirname(item.original_path), exist_ok=True)
                with open(item.original_path, 'wb') as f:
                    f.write(extracted_data)
            
            # 删除隔离文件
            quarantine_path.unlink()
            return True
            
        except Exception as e:
            self.logger.error(f"恢复隔离文件失败: {e}")
            return False
    
    def _calculate_file_hash(self, file_path: str) -> str:
        """计算文件哈希"""
        try:
            sha256_hash = hashlib.sha256()
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(chunk)
            return sha256_hash.hexdigest()
        except Exception:
            return ""
    
    def cleanup_old_quarantine(self) -> int:
        """清理过期的隔离文件"""
        try:
            cleanup_count = 0
            cutoff_time = datetime.now() - timedelta(days=self.max_quarantine_age)
            
            items_to_remove = []
            for quarantine_id, item in self.quarantined_items.items():
                if item.quarantine_time < cutoff_time:
                    items_to_remove.append(quarantine_id)
            
            for quarantine_id in items_to_remove:
                item = self.quarantined_items[quarantine_id]
                
                # 删除隔离文件
                if item.quarantine_path and os.path.exists(item.quarantine_path):
                    os.remove(item.quarantine_path)
                
                # 从记录中删除
                del self.quarantined_items[quarantine_id]
                cleanup_count += 1
            
            if cleanup_count > 0:
                self._save_quarantine_db()
                self.logger.info(f"清理过期隔离项目: {cleanup_count} 个")
            
            return cleanup_count
            
        except Exception as e:
            self.logger.error(f"清理隔离文件失败: {e}")
            return 0
    
    def get_quarantine_summary(self) -> Dict[str, Any]:
        """获取隔离摘要信息"""
        try:
            total_size = 0
            file_count = 0
            app_count = 0
            
            for item in self.quarantined_items.values():
                if item.metadata.get('quarantine_method') == 'file_move':
                    file_count += 1
                    total_size += item.metadata.get('file_size', 0)
                elif item.metadata.get('quarantine_method') == 'app_disable':
                    app_count += 1
            
            return {
                'total_items': len(self.quarantined_items),
                'file_count': file_count,
                'app_count': app_count,
                'total_size': total_size,
                'oldest_item': min((item.quarantine_time for item in self.quarantined_items.values()),
                                 default=None),
                'newest_item': max((item.quarantine_time for item in self.quarantined_items.values()),
                                 default=None)
            }
            
        except Exception as e:
            self.logger.error(f"获取隔离摘要失败: {e}")
            return {}


class MalwareRemovalEngine(LoggerMixin):
    """恶意软件清除引擎"""
    
    def __init__(self, device_manager: DeviceManager):
        """
        初始化清除引擎
        
        Args:
            device_manager: 设备管理器
        """
        self.device_manager = device_manager
        self.quarantine_manager = QuarantineManager()
        
        # 清除操作记录
        self.removal_history: List[RemovalOperation] = []
        self.max_history = 1000
        
        # 清除策略配置
        self.removal_strategies = {
            'application': ['disable', 'uninstall', 'force_stop'],
            'file': ['quarantine', 'delete'],
            'process': ['kill', 'disable_service']
        }
    
    def remove_malicious_application(self, device_id: str, package_name: str,
                                   malware_info: Dict[str, Any],
                                   strategy: str = 'uninstall') -> bool:
        """
        清除恶意应用
        
        Args:
            device_id: 设备ID
            package_name: 应用包名
            malware_info: 恶意软件信息
            strategy: 清除策略 ('disable', 'uninstall', 'quarantine')
            
        Returns:
            清除是否成功
        """
        operation_id = f"remove_app_{package_name}_{int(datetime.now().timestamp())}"
        
        try:
            success = False
            backup_path = None
            error_message = ""
            
            if strategy == 'quarantine':
                # 隔离应用（禁用但不删除）
                result = self.device_manager.execute_command(
                    device_id, f"pm disable-user {package_name}"
                )
                
                if result and ('disabled' in result.lower() or 'success' in result.lower()):
                    quarantine_id = self.quarantine_manager.quarantine_application(
                        device_id, package_name, malware_info
                    )
                    success = quarantine_id is not None
                    backup_path = quarantine_id
                else:
                    error_message = f"应用禁用失败: {result}"
                    
            elif strategy == 'disable':
                # 仅禁用应用
                result = self.device_manager.execute_command(
                    device_id, f"pm disable-user {package_name}"
                )
                success = result and ('disabled' in result.lower() or 'success' in result.lower())
                if not success:
                    error_message = f"应用禁用失败: {result}"
                    
            elif strategy == 'uninstall':
                # 完全卸载应用
                result = self.device_manager.execute_command(
                    device_id, f"pm uninstall {package_name}"
                )
                success = result and 'success' in result.lower()
                if not success:
                    error_message = f"应用卸载失败: {result}"
                    
            else:
                error_message = f"不支持的清除策略: {strategy}"
            
            # 记录操作
            operation = RemovalOperation(
                operation_id=operation_id,
                target_type='application',
                target_identifier=package_name,
                removal_method=strategy,
                timestamp=datetime.now(),
                success=success,
                backup_path=backup_path,
                error_message=error_message
            )
            
            self.removal_history.append(operation)
            self._trim_history()
            
            if success:
                self.logger.info(f"恶意应用清除成功: {package_name} (策略: {strategy})")
            else:
                self.logger.error(f"恶意应用清除失败: {package_name} - {error_message}")
            
            return success
            
        except Exception as e:
            self.logger.error(f"清除恶意应用异常: {e}")
            return False
    
    def remove_malicious_file(self, file_path: str, malware_info: Dict[str, Any],
                            strategy: str = 'quarantine') -> bool:
        """
        清除恶意文件
        
        Args:
            file_path: 文件路径
            malware_info: 恶意软件信息
            strategy: 清除策略 ('quarantine', 'delete')
            
        Returns:
            清除是否成功
        """
        operation_id = f"remove_file_{os.path.basename(file_path)}_{int(datetime.now().timestamp())}"
        
        try:
            success = False
            backup_path = None
            error_message = ""
            
            if not os.path.exists(file_path):
                error_message = "文件不存在"
            elif strategy == 'quarantine':
                # 隔离文件
                quarantine_id = self.quarantine_manager.quarantine_file(file_path, malware_info)
                success = quarantine_id is not None
                backup_path = quarantine_id
                if not success:
                    error_message = "文件隔离失败"
                    
            elif strategy == 'delete':
                # 直接删除文件
                try:
                    os.remove(file_path)
                    success = True
                except Exception as e:
                    error_message = f"文件删除失败: {e}"
            else:
                error_message = f"不支持的清除策略: {strategy}"
            
            # 记录操作
            operation = RemovalOperation(
                operation_id=operation_id,
                target_type='file',
                target_identifier=file_path,
                removal_method=strategy,
                timestamp=datetime.now(),
                success=success,
                backup_path=backup_path,
                error_message=error_message
            )
            
            self.removal_history.append(operation)
            self._trim_history()
            
            if success:
                self.logger.info(f"恶意文件清除成功: {file_path} (策略: {strategy})")
            else:
                self.logger.error(f"恶意文件清除失败: {file_path} - {error_message}")
            
            return success
            
        except Exception as e:
            self.logger.error(f"清除恶意文件异常: {e}")
            return False
    
    def kill_malicious_process(self, device_id: str, process_info: Dict[str, Any]) -> bool:
        """
        终止恶意进程
        
        Args:
            device_id: 设备ID
            process_info: 进程信息，应包含pid或package_name
            
        Returns:
            终止是否成功
        """
        operation_id = f"kill_process_{int(datetime.now().timestamp())}"
        
        try:
            success = False
            error_message = ""
            target_identifier = ""
            
            # 尝试通过PID终止
            if 'pid' in process_info:
                pid = process_info['pid']
                target_identifier = f"PID:{pid}"
                result = self.device_manager.execute_command(device_id, f"kill {pid}")
                success = result is not None
                if not success:
                    error_message = f"进程终止失败: PID {pid}"
            
            # 尝试通过包名强制停止
            elif 'package_name' in process_info:
                package_name = process_info['package_name']
                target_identifier = f"Package:{package_name}"
                result = self.device_manager.execute_command(
                    device_id, f"am force-stop {package_name}"
                )
                success = result is not None
                if not success:
                    error_message = f"应用强制停止失败: {package_name}"
            else:
                error_message = "缺少进程标识信息"
            
            # 记录操作
            operation = RemovalOperation(
                operation_id=operation_id,
                target_type='process',
                target_identifier=target_identifier,
                removal_method='kill',
                timestamp=datetime.now(),
                success=success,
                error_message=error_message
            )
            
            self.removal_history.append(operation)
            self._trim_history()
            
            if success:
                self.logger.info(f"恶意进程终止成功: {target_identifier}")
            else:
                self.logger.error(f"恶意进程终止失败: {target_identifier} - {error_message}")
            
            return success
            
        except Exception as e:
            self.logger.error(f"终止恶意进程异常: {e}")
            return False
    
    def batch_remove_malware(self, removal_requests: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        批量清除恶意软件
        
        Args:
            removal_requests: 清除请求列表，每个请求包含type, target, strategy等信息
            
        Returns:
            批量清除结果摘要
        """
        results = {
            'total_requests': len(removal_requests),
            'successful_removals': 0,
            'failed_removals': 0,
            'operations': []
        }
        
        try:
            for request in removal_requests:
                request_type = request.get('type')
                target = request.get('target')
                strategy = request.get('strategy', 'quarantine')
                malware_info = request.get('malware_info', {})
                device_id = request.get('device_id', '')
                
                success = False
                
                if request_type == 'application':
                    success = self.remove_malicious_application(
                        device_id, target, malware_info, strategy
                    )
                elif request_type == 'file':
                    success = self.remove_malicious_file(target, malware_info, strategy)
                elif request_type == 'process':
                    success = self.kill_malicious_process(device_id, target)
                
                if success:
                    results['successful_removals'] += 1
                else:
                    results['failed_removals'] += 1
                
                results['operations'].append({
                    'type': request_type,
                    'target': target,
                    'strategy': strategy,
                    'success': success
                })
            
            self.logger.info(f"批量清除完成: {results['successful_removals']}/{results['total_requests']} 成功")
            
        except Exception as e:
            self.logger.error(f"批量清除异常: {e}")
            results['error'] = str(e)
        
        return results
    
    def _trim_history(self):
        """修剪历史记录"""
        if len(self.removal_history) > self.max_history:
            self.removal_history = self.removal_history[-self.max_history:]
    
    def get_removal_statistics(self) -> Dict[str, Any]:
        """获取清除统计信息"""
        try:
            if not self.removal_history:
                return {'total_operations': 0}
            
            total_ops = len(self.removal_history)
            successful_ops = sum(1 for op in self.removal_history if op.success)
            
            # 按类型统计
            type_stats = {}
            for op in self.removal_history:
                if op.target_type not in type_stats:
                    type_stats[op.target_type] = {'total': 0, 'success': 0}
                type_stats[op.target_type]['total'] += 1
                if op.success:
                    type_stats[op.target_type]['success'] += 1
            
            # 按策略统计
            method_stats = {}
            for op in self.removal_history:
                if op.removal_method not in method_stats:
                    method_stats[op.removal_method] = {'total': 0, 'success': 0}
                method_stats[op.removal_method]['total'] += 1
                if op.success:
                    method_stats[op.removal_method]['success'] += 1
            
            return {
                'total_operations': total_ops,
                'successful_operations': successful_ops,
                'success_rate': successful_ops / total_ops,
                'type_statistics': type_stats,
                'method_statistics': method_stats,
                'quarantine_summary': self.quarantine_manager.get_quarantine_summary()
            }
            
        except Exception as e:
            self.logger.error(f"获取清除统计失败: {e}")
            return {'error': str(e)}
    
    def restore_quarantined_item(self, quarantine_id: str) -> bool:
        """恢复隔离项目"""
        return self.quarantine_manager.restore_quarantined_item(quarantine_id)
    
    def cleanup_old_quarantine(self) -> int:
        """清理过期隔离文件"""
        return self.quarantine_manager.cleanup_old_quarantine()