#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
漏洞评级系统和修复优先级算法
提供智能化的漏洞风险评估、优先级排序和修复策略建议
"""

import math
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum

from ..models import ThreatLevel, Severity
from ..utils.logger import LoggerMixin


class VulnerabilityRating(Enum):
    """漏洞评级枚举"""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"


class RepairPriority(Enum):
    """修复优先级枚举"""
    URGENT = "URGENT"          # 紧急 - 24小时内
    HIGH = "HIGH"              # 高 - 72小时内
    MEDIUM = "MEDIUM"          # 中 - 1周内
    LOW = "LOW"                # 低 - 1个月内
    SCHEDULED = "SCHEDULED"    # 计划内 - 下次维护时


@dataclass
class VulnerabilityScore:
    """漏洞评分"""
    base_score: float          # CVSS基础分数
    temporal_score: float      # 时间分数
    environmental_score: float # 环境分数
    composite_score: float     # 综合分数
    rating: VulnerabilityRating
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'base_score': self.base_score,
            'temporal_score': self.temporal_score,
            'environmental_score': self.environmental_score,
            'composite_score': self.composite_score,
            'rating': self.rating.value
        }


@dataclass
class RepairRecommendation:
    """修复建议"""
    vulnerability_id: str
    priority: RepairPriority
    estimated_effort: int      # 预估修复时间(小时)
    required_resources: List[str]
    dependencies: List[str]    # 依赖的其他修复
    automated_fix: bool        # 是否可自动修复
    rollback_supported: bool   # 是否支持回滚
    business_impact: str       # 业务影响评估
    recommended_timeline: str  # 建议修复时间
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'vulnerability_id': self.vulnerability_id,
            'priority': self.priority.value,
            'estimated_effort': self.estimated_effort,
            'required_resources': self.required_resources,
            'dependencies': self.dependencies,
            'automated_fix': self.automated_fix,
            'rollback_supported': self.rollback_supported,
            'business_impact': self.business_impact,
            'recommended_timeline': self.recommended_timeline
        }


class VulnerabilityRatingEngine(LoggerMixin):
    """漏洞评级引擎"""
    
    def __init__(self):
        """初始化漏洞评级引擎"""
        # CVSS评分权重配置
        self.cvss_weights = {
            'attack_vector': {'network': 0.85, 'adjacent': 0.62, 'local': 0.55, 'physical': 0.2},
            'attack_complexity': {'low': 0.77, 'high': 0.44},
            'privileges_required': {'none': 0.85, 'low': 0.62, 'high': 0.27},
            'user_interaction': {'none': 0.85, 'required': 0.62},
            'scope': {'unchanged': 0.0, 'changed': 0.0},  # 用于计算影响分数
            'confidentiality': {'high': 0.56, 'low': 0.22, 'none': 0.0},
            'integrity': {'high': 0.56, 'low': 0.22, 'none': 0.0},
            'availability': {'high': 0.56, 'low': 0.22, 'none': 0.0}
        }
        
        # 评级阈值
        self.rating_thresholds = {
            VulnerabilityRating.CRITICAL: (9.0, 10.0),
            VulnerabilityRating.HIGH: (7.0, 8.9),
            VulnerabilityRating.MEDIUM: (4.0, 6.9),
            VulnerabilityRating.LOW: (0.1, 3.9),
            VulnerabilityRating.INFO: (0.0, 0.0)
        }
        
        # 时间因子
        self.temporal_factors = {
            'exploit_code_maturity': {'not_defined': 1.0, 'proof_of_concept': 0.94, 'functional': 0.97, 'high': 1.0},
            'remediation_level': {'not_defined': 1.0, 'official_fix': 0.95, 'temporary_fix': 0.96, 'workaround': 0.97, 'unavailable': 1.0},
            'report_confidence': {'not_defined': 1.0, 'unknown': 0.92, 'reasonable': 0.96, 'confirmed': 1.0}
        }
        
        # 环境因子
        self.environmental_factors = {
            'system_criticality': {'low': 0.5, 'medium': 1.0, 'high': 1.5, 'critical': 2.0},
            'data_sensitivity': {'public': 0.5, 'internal': 1.0, 'confidential': 1.5, 'restricted': 2.0},
            'network_exposure': {'internal': 0.5, 'partner': 1.0, 'internet': 1.5},
            'user_count': {'few': 0.5, 'some': 1.0, 'many': 1.5, 'all': 2.0}
        }
    
    def calculate_vulnerability_score(self, vuln_data: Dict[str, Any]) -> VulnerabilityScore:
        """
        计算漏洞综合评分
        
        Args:
            vuln_data: 漏洞数据，包含CVSS向量、环境因素等
            
        Returns:
            漏洞评分对象
        """
        try:
            # 计算基础分数
            base_score = self._calculate_base_score(vuln_data.get('cvss', {}))
            
            # 计算时间分数
            temporal_score = self._calculate_temporal_score(
                base_score, vuln_data.get('temporal', {})
            )
            
            # 计算环境分数
            environmental_score = self._calculate_environmental_score(
                temporal_score, vuln_data.get('environmental', {})
            )
            
            # 确定综合分数（优先使用环境分数）
            composite_score = environmental_score if environmental_score > 0 else (
                temporal_score if temporal_score > 0 else base_score
            )
            
            # 确定评级
            rating = self._determine_rating(composite_score)
            
            return VulnerabilityScore(
                base_score=base_score,
                temporal_score=temporal_score,
                environmental_score=environmental_score,
                composite_score=composite_score,
                rating=rating
            )
            
        except Exception as e:
            self.logger.error(f"漏洞评分计算失败: {e}")
            return VulnerabilityScore(0.0, 0.0, 0.0, 0.0, VulnerabilityRating.INFO)
    
    def _calculate_base_score(self, cvss_data: Dict[str, Any]) -> float:
        """计算CVSS基础分数"""
        try:
            # 可利用性分数
            av = self.cvss_weights['attack_vector'].get(cvss_data.get('attack_vector', 'local'), 0.55)
            ac = self.cvss_weights['attack_complexity'].get(cvss_data.get('attack_complexity', 'high'), 0.44)
            pr = self.cvss_weights['privileges_required'].get(cvss_data.get('privileges_required', 'high'), 0.27)
            ui = self.cvss_weights['user_interaction'].get(cvss_data.get('user_interaction', 'required'), 0.62)
            
            exploitability = 8.22 * av * ac * pr * ui
            
            # 影响分数
            c = self.cvss_weights['confidentiality'].get(cvss_data.get('confidentiality', 'none'), 0.0)
            i = self.cvss_weights['integrity'].get(cvss_data.get('integrity', 'none'), 0.0)
            a = self.cvss_weights['availability'].get(cvss_data.get('availability', 'none'), 0.0)
            
            iss = 1 - ((1 - c) * (1 - i) * (1 - a))
            
            # 范围变更计算
            scope_changed = cvss_data.get('scope') == 'changed'
            if scope_changed:
                impact = 7.52 * (iss - 0.029) - 3.25 * pow(iss - 0.02, 15)
            else:
                impact = 6.42 * iss
            
            # 基础分数计算
            if impact <= 0:
                base_score = 0.0
            elif scope_changed:
                base_score = min(1.08 * (impact + exploitability), 10.0)
            else:
                base_score = min(impact + exploitability, 10.0)
            
            # 四舍五入到小数点后1位
            return round(base_score, 1)
            
        except Exception as e:
            self.logger.error(f"基础分数计算失败: {e}")
            return 0.0
    
    def _calculate_temporal_score(self, base_score: float, temporal_data: Dict[str, Any]) -> float:
        """计算时间分数"""
        try:
            if base_score == 0:
                return 0.0
            
            # 时间因子
            e = self.temporal_factors['exploit_code_maturity'].get(
                temporal_data.get('exploit_code_maturity', 'not_defined'), 1.0
            )
            rl = self.temporal_factors['remediation_level'].get(
                temporal_data.get('remediation_level', 'not_defined'), 1.0
            )
            rc = self.temporal_factors['report_confidence'].get(
                temporal_data.get('report_confidence', 'not_defined'), 1.0
            )
            
            temporal_score = base_score * e * rl * rc
            return round(temporal_score, 1)
            
        except Exception as e:
            self.logger.error(f"时间分数计算失败: {e}")
            return base_score
    
    def _calculate_environmental_score(self, temporal_score: float, env_data: Dict[str, Any]) -> float:
        """计算环境分数"""
        try:
            if not env_data or temporal_score == 0:
                return 0.0
            
            # 环境因子乘数
            multiplier = 1.0
            
            for factor, value in env_data.items():
                if factor in self.environmental_factors:
                    factor_multiplier = self.environmental_factors[factor].get(value, 1.0)
                    multiplier *= factor_multiplier
            
            environmental_score = temporal_score * multiplier
            return round(min(environmental_score, 10.0), 1)
            
        except Exception as e:
            self.logger.error(f"环境分数计算失败: {e}")
            return 0.0
    
    def _determine_rating(self, score: float) -> VulnerabilityRating:
        """根据分数确定评级"""
        for rating, (min_score, max_score) in self.rating_thresholds.items():
            if min_score <= score <= max_score:
                return rating
        return VulnerabilityRating.INFO


class RepairPriorityEngine(LoggerMixin):
    """修复优先级引擎"""
    
    def __init__(self):
        """初始化修复优先级引擎"""
        # 优先级计算权重
        self.priority_weights = {
            'severity': 0.4,           # 严重程度权重
            'exploitability': 0.25,    # 可利用性权重
            'business_impact': 0.2,    # 业务影响权重
            'asset_value': 0.15        # 资产价值权重
        }
        
        # 修复时间估算（小时）
        self.repair_time_estimates = {
            VulnerabilityRating.CRITICAL: {'min': 2, 'max': 8, 'avg': 4},
            VulnerabilityRating.HIGH: {'min': 4, 'max': 16, 'avg': 8},
            VulnerabilityRating.MEDIUM: {'min': 8, 'max': 32, 'avg': 16},
            VulnerabilityRating.LOW: {'min': 16, 'max': 64, 'avg': 32},
            VulnerabilityRating.INFO: {'min': 1, 'max': 4, 'avg': 2}
        }
        
        # 优先级映射
        self.priority_mapping = {
            (9.0, 10.0): RepairPriority.URGENT,
            (7.5, 8.9): RepairPriority.HIGH,
            (5.0, 7.4): RepairPriority.MEDIUM,
            (2.0, 4.9): RepairPriority.LOW,
            (0.0, 1.9): RepairPriority.SCHEDULED
        }
    
    def calculate_repair_priority(self, vuln_data: Dict[str, Any]) -> RepairRecommendation:
        """
        计算修复优先级
        
        Args:
            vuln_data: 漏洞数据
            
        Returns:
            修复建议对象
        """
        try:
            vuln_id = vuln_data.get('id', 'unknown')
            
            # 计算优先级分数
            priority_score = self._calculate_priority_score(vuln_data)
            
            # 确定优先级
            priority = self._determine_priority(priority_score)
            
            # 估算修复工作量
            estimated_effort = self._estimate_repair_effort(vuln_data)
            
            # 生成修复建议
            recommendation = RepairRecommendation(
                vulnerability_id=vuln_id,
                priority=priority,
                estimated_effort=estimated_effort,
                required_resources=self._identify_required_resources(vuln_data),
                dependencies=self._identify_dependencies(vuln_data),
                automated_fix=self._check_automation_feasibility(vuln_data),
                rollback_supported=self._check_rollback_support(vuln_data),
                business_impact=self._assess_business_impact(vuln_data),
                recommended_timeline=self._recommend_timeline(priority)
            )
            
            return recommendation
            
        except Exception as e:
            self.logger.error(f"修复优先级计算失败: {e}")
            return RepairRecommendation(
                vulnerability_id=vuln_data.get('id', 'unknown'),
                priority=RepairPriority.LOW,
                estimated_effort=8,
                required_resources=[],
                dependencies=[],
                automated_fix=False,
                rollback_supported=False,
                business_impact="未知",
                recommended_timeline="待评估"
            )
    
    def _calculate_priority_score(self, vuln_data: Dict[str, Any]) -> float:
        """计算优先级分数"""
        try:
            # 严重程度分数
            severity_score = vuln_data.get('composite_score', 0.0)
            
            # 可利用性分数
            exploitability_score = self._calculate_exploitability_score(vuln_data)
            
            # 业务影响分数
            business_impact_score = self._calculate_business_impact_score(vuln_data)
            
            # 资产价值分数
            asset_value_score = self._calculate_asset_value_score(vuln_data)
            
            # 加权计算
            priority_score = (
                severity_score * self.priority_weights['severity'] +
                exploitability_score * self.priority_weights['exploitability'] +
                business_impact_score * self.priority_weights['business_impact'] +
                asset_value_score * self.priority_weights['asset_value']
            )
            
            return min(priority_score, 10.0)
            
        except Exception as e:
            self.logger.error(f"优先级分数计算失败: {e}")
            return 0.0
    
    def _calculate_exploitability_score(self, vuln_data: Dict[str, Any]) -> float:
        """计算可利用性分数"""
        score = 5.0  # 默认中等可利用性
        
        # 检查是否有公开exploit
        if vuln_data.get('exploit_available', False):
            score += 3.0
        
        # 检查攻击复杂度
        attack_complexity = vuln_data.get('cvss', {}).get('attack_complexity', 'high')
        if attack_complexity == 'low':
            score += 2.0
        elif attack_complexity == 'high':
            score -= 1.0
        
        # 检查所需权限
        privileges = vuln_data.get('cvss', {}).get('privileges_required', 'high')
        if privileges == 'none':
            score += 2.0
        elif privileges == 'low':
            score += 1.0
        
        return min(max(score, 0.0), 10.0)
    
    def _calculate_business_impact_score(self, vuln_data: Dict[str, Any]) -> float:
        """计算业务影响分数"""
        impact_factors = {
            'confidentiality': vuln_data.get('cvss', {}).get('confidentiality', 'none'),
            'integrity': vuln_data.get('cvss', {}).get('integrity', 'none'),
            'availability': vuln_data.get('cvss', {}).get('availability', 'none')
        }
        
        impact_weights = {'high': 3.0, 'low': 1.0, 'none': 0.0}
        
        total_impact = sum(impact_weights.get(impact, 0.0) for impact in impact_factors.values())
        
        # 归一化到0-10范围
        normalized_impact = (total_impact / 9.0) * 10.0
        
        return min(normalized_impact, 10.0)
    
    def _calculate_asset_value_score(self, vuln_data: Dict[str, Any]) -> float:
        """计算资产价值分数"""
        asset_criticality = vuln_data.get('asset_criticality', 'medium')
        
        criticality_scores = {
            'critical': 10.0,
            'high': 8.0,
            'medium': 5.0,
            'low': 2.0
        }
        
        return criticality_scores.get(asset_criticality, 5.0)
    
    def _determine_priority(self, priority_score: float) -> RepairPriority:
        """根据分数确定优先级"""
        for (min_score, max_score), priority in self.priority_mapping.items():
            if min_score <= priority_score <= max_score:
                return priority
        return RepairPriority.LOW
    
    def _estimate_repair_effort(self, vuln_data: Dict[str, Any]) -> int:
        """估算修复工作量"""
        rating = VulnerabilityRating(vuln_data.get('rating', 'MEDIUM'))
        
        # 基础时间估算
        base_time = self.repair_time_estimates[rating]['avg']
        
        # 复杂度调整
        complexity = vuln_data.get('fix_complexity', 'medium')
        complexity_multipliers = {'low': 0.5, 'medium': 1.0, 'high': 1.5, 'very_high': 2.0}
        multiplier = complexity_multipliers.get(complexity, 1.0)
        
        # 依赖数量调整
        dependencies_count = len(vuln_data.get('dependencies', []))
        dependency_multiplier = 1.0 + (dependencies_count * 0.2)
        
        estimated_time = int(base_time * multiplier * dependency_multiplier)
        
        return max(estimated_time, 1)
    
    def _identify_required_resources(self, vuln_data: Dict[str, Any]) -> List[str]:
        """识别所需资源"""
        resources = []
        
        vuln_type = vuln_data.get('type', 'unknown')
        
        # 根据漏洞类型确定资源需求
        if 'system' in vuln_type.lower():
            resources.extend(['系统管理员', '重启权限'])
        
        if 'application' in vuln_type.lower():
            resources.extend(['开发团队', '应用更新权限'])
        
        if 'network' in vuln_type.lower():
            resources.extend(['网络管理员', '防火墙配置权限'])
        
        if 'config' in vuln_type.lower():
            resources.append('配置管理权限')
        
        return list(set(resources))
    
    def _identify_dependencies(self, vuln_data: Dict[str, Any]) -> List[str]:
        """识别修复依赖"""
        # 从漏洞数据中提取依赖关系
        return vuln_data.get('dependencies', [])
    
    def _check_automation_feasibility(self, vuln_data: Dict[str, Any]) -> bool:
        """检查自动化修复可行性"""
        # 简单规则：配置类问题通常可自动修复
        vuln_type = vuln_data.get('type', 'unknown').lower()
        automated_types = ['config', 'permission', 'setting']
        
        return any(auto_type in vuln_type for auto_type in automated_types)
    
    def _check_rollback_support(self, vuln_data: Dict[str, Any]) -> bool:
        """检查回滚支持"""
        # 配置更改通常支持回滚
        vuln_type = vuln_data.get('type', 'unknown').lower()
        rollback_supported_types = ['config', 'setting', 'permission']
        
        return any(rb_type in vuln_type for rb_type in rollback_supported_types)
    
    def _assess_business_impact(self, vuln_data: Dict[str, Any]) -> str:
        """评估业务影响"""
        impact_levels = {
            VulnerabilityRating.CRITICAL: "严重 - 可能导致业务中断或数据泄露",
            VulnerabilityRating.HIGH: "较高 - 可能影响核心业务功能",
            VulnerabilityRating.MEDIUM: "中等 - 对业务有一定影响",
            VulnerabilityRating.LOW: "较低 - 对业务影响轻微",
            VulnerabilityRating.INFO: "信息性 - 无直接业务影响"
        }
        
        rating = VulnerabilityRating(vuln_data.get('rating', 'MEDIUM'))
        return impact_levels.get(rating, "影响待评估")
    
    def _recommend_timeline(self, priority: RepairPriority) -> str:
        """建议修复时间线"""
        timelines = {
            RepairPriority.URGENT: "24小时内必须完成",
            RepairPriority.HIGH: "72小时内完成",
            RepairPriority.MEDIUM: "1周内完成",
            RepairPriority.LOW: "1个月内完成",
            RepairPriority.SCHEDULED: "下次计划维护时处理"
        }
        
        return timelines.get(priority, "时间线待确定")


class VulnerabilityPrioritizationEngine(LoggerMixin):
    """漏洞优先级排序引擎"""
    
    def __init__(self):
        """初始化优先级排序引擎"""
        self.rating_engine = VulnerabilityRatingEngine()
        self.priority_engine = RepairPriorityEngine()
        
    def prioritize_vulnerabilities(self, vulnerabilities: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        对漏洞列表进行优先级排序
        
        Args:
            vulnerabilities: 漏洞列表
            
        Returns:
            排序后的漏洞列表，包含评分和修复建议
        """
        try:
            prioritized_vulns = []
            
            for vuln in vulnerabilities:
                # 计算漏洞评分
                score = self.rating_engine.calculate_vulnerability_score(vuln)
                
                # 添加评分到漏洞数据
                vuln_with_score = vuln.copy()
                vuln_with_score.update({
                    'vulnerability_score': score.to_dict(),
                    'composite_score': score.composite_score,
                    'rating': score.rating.value
                })
                
                # 计算修复建议
                repair_recommendation = self.priority_engine.calculate_repair_priority(vuln_with_score)
                vuln_with_score['repair_recommendation'] = repair_recommendation.to_dict()
                
                prioritized_vulns.append(vuln_with_score)
            
            # 按综合评分排序（降序）
            prioritized_vulns.sort(key=lambda x: x['composite_score'], reverse=True)
            
            self.logger.info(f"已对{len(vulnerabilities)}个漏洞进行优先级排序")
            
            return prioritized_vulns
            
        except Exception as e:
            self.logger.error(f"漏洞优先级排序失败: {e}")
            return vulnerabilities
    
    def generate_repair_plan(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        生成修复计划
        
        Args:
            vulnerabilities: 已排序的漏洞列表
            
        Returns:
            修复计划
        """
        try:
            # 按优先级分组
            priority_groups = {
                'urgent': [],
                'high': [],
                'medium': [],
                'low': [],
                'scheduled': []
            }
            
            total_effort = 0
            
            for vuln in vulnerabilities:
                recommendation = vuln.get('repair_recommendation', {})
                priority = recommendation.get('priority', 'LOW').lower()
                
                if priority in priority_groups:
                    priority_groups[priority].append(vuln)
                
                total_effort += recommendation.get('estimated_effort', 0)
            
            # 生成时间线
            timeline = self._generate_timeline(priority_groups)
            
            # 统计信息
            statistics = {
                'total_vulnerabilities': len(vulnerabilities),
                'by_priority': {k: len(v) for k, v in priority_groups.items()},
                'total_estimated_effort': total_effort,
                'estimated_completion_days': math.ceil(total_effort / 8)  # 按每天8小时计算
            }
            
            repair_plan = {
                'generated_at': datetime.now().isoformat(),
                'statistics': statistics,
                'priority_groups': priority_groups,
                'timeline': timeline,
                'recommendations': self._generate_plan_recommendations(statistics)
            }
            
            return repair_plan
            
        except Exception as e:
            self.logger.error(f"修复计划生成失败: {e}")
            return {'error': str(e)}
    
    def _generate_timeline(self, priority_groups: Dict[str, List]) -> Dict[str, str]:
        """生成修复时间线"""
        now = datetime.now()
        
        timeline = {
            'urgent': (now + timedelta(hours=24)).strftime('%Y-%m-%d %H:%M'),
            'high': (now + timedelta(days=3)).strftime('%Y-%m-%d %H:%M'),
            'medium': (now + timedelta(weeks=1)).strftime('%Y-%m-%d %H:%M'),
            'low': (now + timedelta(days=30)).strftime('%Y-%m-%d %H:%M'),
            'scheduled': '下次维护窗口'
        }
        
        return timeline
    
    def _generate_plan_recommendations(self, statistics: Dict[str, Any]) -> List[str]:
        """生成计划建议"""
        recommendations = []
        
        urgent_count = statistics['by_priority'].get('urgent', 0)
        high_count = statistics['by_priority'].get('high', 0)
        
        if urgent_count > 0:
            recommendations.append(f"立即处理{urgent_count}个紧急漏洞，优先分配资源")
        
        if high_count > 5:
            recommendations.append("高优先级漏洞数量较多，建议增加人力资源")
        
        if statistics['estimated_completion_days'] > 30:
            recommendations.append("预计完成时间较长，建议分阶段实施修复计划")
        
        if not recommendations:
            recommendations.append("漏洞风险整体可控，按计划执行修复即可")
        
        return recommendations