#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
漏洞检测引擎
支持Android系统漏洞、应用漏洞和配置缺陷检测
"""

import re
import json
from typing import Dict, List, Optional, Tuple, Any
from datetime import datetime
from pathlib import Path

from ..models import (
    DeviceInfo, VulnerabilityReport, Issue, IssueCategory,   # pyright: ignore[reportAttributeAccessIssue]
    IssueSeverity, ThreatLevel
)
from ..utils.logger import LoggerMixin
from .device_manager import DeviceManager


class VulnerabilityDatabase:
    """漏洞数据库"""
    
    def __init__(self, db_path: str = "data/vulnerabilities"):
        self.db_path = Path(db_path)
        self.db_path.mkdir(parents=True, exist_ok=True)
        self.vulnerabilities = self._load_vulnerability_database()
    
    def _load_vulnerability_database(self) -> Dict[str, Any]:
        """加载漏洞数据库"""
        return {
            'system_vulnerabilities': [
                {
                    'id': 'CVE-2019-2215',
                    'name': 'Android内核提权漏洞',
                    'severity': 'CRITICAL',
                    'affected_versions': ['< 10.0'],
                    'description': 'Linux内核use-after-free漏洞'
                },
                {
                    'id': 'CVE-2020-0041', 
                    'name': 'Android binder驱动漏洞',
                    'severity': 'HIGH',
                    'affected_versions': ['< 11.0'],
                    'description': 'binder驱动内存损坏漏洞'
                }
            ],
            'config_vulnerabilities': [
                {
                    'check': 'adb_enabled',
                    'severity': 'MEDIUM',
                    'description': 'ADB调试功能已启用'
                },
                {
                    'check': 'unknown_sources',
                    'severity': 'MEDIUM', 
                    'description': '允许安装未知来源应用'
                },
                {
                    'check': 'developer_options',
                    'severity': 'LOW',
                    'description': '开发者选项已启用'
                }
            ]
        }


class VulnerabilityScanner(LoggerMixin):
    """漏洞扫描器"""
    
    def __init__(self, device_manager: DeviceManager):
        self.device_manager = device_manager
        self.vuln_db = VulnerabilityDatabase()
    
    def scan_system_vulnerabilities(self, device_id: str) -> List[Dict[str, Any]]:
        """扫描系统漏洞"""
        vulnerabilities = []
        
        try:
            # 获取Android版本
            android_version = self._get_android_version(device_id)
            
            # 检查已知系统漏洞
            for vuln in self.vuln_db.vulnerabilities['system_vulnerabilities']:
                if self._is_vulnerable(android_version, vuln['affected_versions']):
                    vulnerabilities.append({
                        'vuln_id': vuln['id'],
                        'name': vuln['name'],
                        'severity': vuln['severity'],
                        'description': vuln['description'],
                        'type': 'SYSTEM'
                    })
            
        except Exception as e:
            self.logger.error(f"系统漏洞扫描失败: {e}")
        
        return vulnerabilities
    
    def scan_configuration_issues(self, device_id: str) -> List[Dict[str, Any]]:
        """扫描配置问题"""
        issues = []
        
        try:
            # 检查ADB状态
            if self._check_adb_enabled(device_id):
                issues.append({
                    'name': 'ADB调试已启用',
                    'severity': 'MEDIUM',
                    'description': 'ADB调试功能存在安全风险',
                    'type': 'CONFIG'
                })
            
            # 检查未知来源安装
            if self._check_unknown_sources(device_id):
                issues.append({
                    'name': '允许未知来源安装',
                    'severity': 'HIGH', 
                    'description': '允许安装未验证的应用',
                    'type': 'CONFIG'
                })
        
        except Exception as e:
            self.logger.error(f"配置检查失败: {e}")
        
        return issues
    
    def _get_android_version(self, device_id: str) -> str:
        """获取Android版本"""
        result = self.device_manager.execute_command(  # pyright: ignore[reportAttributeAccessIssue]
            device_id, "getprop ro.build.version.release"
        )
        return result.strip() if result else "unknown"
    
    def _is_vulnerable(self, current_version: str, affected_versions: List[str]) -> bool:
        """检查版本是否存在漏洞"""
        try:
            current = float(current_version.split('.')[0])
            for version_range in affected_versions:
                if '<' in version_range:
                    max_version = float(version_range.replace('<', '').strip())
                    if current < max_version:
                        return True
        except:
            pass
        return False
    
    def _check_adb_enabled(self, device_id: str) -> bool:
        """检查ADB是否启用"""
        result = self.device_manager.execute_command(  # pyright: ignore[reportAttributeAccessIssue]
            device_id, "getprop service.adb.root"
        )
        return result and result.strip() == "1"
    
    def _check_unknown_sources(self, device_id: str) -> bool:
        """检查未知来源安装是否允许"""
        result = self.device_manager.execute_command(  # pyright: ignore[reportAttributeAccessIssue]
            device_id, "settings get global install_non_market_apps"
        )
        return result and result.strip() == "1"


class VulnerabilityDetectionEngine(LoggerMixin):
    """漏洞检测引擎"""
    
    def __init__(self, device_manager: DeviceManager):
        self.device_manager = device_manager
        self.scanner = VulnerabilityScanner(device_manager)
    
    def scan_vulnerabilities(self, device_id: str) -> Optional[VulnerabilityReport]:
        """扫描设备漏洞"""
        try:
            # 扫描系统漏洞
            system_vulns = self.scanner.scan_system_vulnerabilities(device_id)
            
            # 扫描配置问题
            config_issues = self.scanner.scan_configuration_issues(device_id)
            
            # 合并所有漏洞
            all_vulnerabilities = system_vulns + config_issues
            
            # 计算风险等级
            risk_level = self._calculate_risk_level(all_vulnerabilities)
            
            return VulnerabilityReport(
                device_id=device_id,
                vulnerability_count=len(all_vulnerabilities),
                critical_count=len([v for v in all_vulnerabilities if v['severity'] == 'CRITICAL']),
                high_count=len([v for v in all_vulnerabilities if v['severity'] == 'HIGH']),
                medium_count=len([v for v in all_vulnerabilities if v['severity'] == 'MEDIUM']),
                low_count=len([v for v in all_vulnerabilities if v['severity'] == 'LOW']),
                risk_level=risk_level,
                vulnerabilities=all_vulnerabilities,
                scan_summary={
                    'scan_time': datetime.now(),
                    'total_checks': len(system_vulns) + len(config_issues)
                }
            )
            
        except Exception as e:
            self.logger.error(f"漏洞扫描失败: {e}")
            return None
    
    def _calculate_risk_level(self, vulnerabilities: List[Dict[str, Any]]) -> ThreatLevel:
        """计算风险等级"""
        if any(v['severity'] == 'CRITICAL' for v in vulnerabilities):
            return ThreatLevel.CRITICAL
        elif any(v['severity'] == 'HIGH' for v in vulnerabilities):
            return ThreatLevel.HIGH
        elif any(v['severity'] == 'MEDIUM' for v in vulnerabilities):
            return ThreatLevel.MEDIUM
        else:
            return ThreatLevel.LOW