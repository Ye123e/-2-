#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
漏洞检测引擎
支持Android系统漏洞、应用漏洞和配置缺陷检测
"""

import re
import json
import subprocess
from typing import Dict, List, Optional, Tuple, Any
from datetime import datetime
from pathlib import Path
from dataclasses import dataclass, field

from ..models import (
    DeviceInfo, VulnerabilityReport, Issue, IssueCategory,   # pyright: ignore[reportAttributeAccessIssue]
    IssueSeverity, ThreatLevel
)
from ..utils.logger import LoggerMixin
from .device_manager import DeviceManager


@dataclass
class SystemVulnerability:
    """系统漏洞信息"""
    cve_id: str
    name: str
    severity: str
    cvss_score: float
    affected_versions: List[str]
    description: str
    exploit_available: bool = False
    patch_available: bool = False
    mitigation: str = ""
    references: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'cve_id': self.cve_id,
            'name': self.name,
            'severity': self.severity,
            'cvss_score': self.cvss_score,
            'affected_versions': self.affected_versions,
            'description': self.description,
            'exploit_available': self.exploit_available,
            'patch_available': self.patch_available,
            'mitigation': self.mitigation,
            'references': self.references
        }


@dataclass
class KernelSecurityInfo:
    """内核安全信息"""
    kernel_version: str
    security_features: Dict[str, bool]
    selinux_status: str
    aslr_enabled: bool
    stack_protection: bool
    kernel_guards: List[str]
    vulnerabilities: List[str] = field(default_factory=list)


class VulnerabilityDatabase:
    """漏洞数据库"""
    
    def __init__(self, db_path: str = "data/vulnerabilities"):
        self.db_path = Path(db_path)
        self.db_path.mkdir(parents=True, exist_ok=True)
        self.vulnerabilities = self._load_vulnerability_database()
        self.kernel_exploits = self._load_kernel_exploits()
        self.security_patches = self._load_security_patches()
    
    def _load_vulnerability_database(self) -> Dict[str, Any]:
        """加载漏洞数据库"""
        return {
            'system_vulnerabilities': [
                SystemVulnerability(
                    cve_id='CVE-2019-2215',
                    name='Android内核提权漏洞',
                    severity='CRITICAL',
                    cvss_score=7.8,
                    affected_versions=['< 10.0'],
                    description='Linux内核use-after-free漏洞，允许本地攻击者提升权限',
                    exploit_available=True,
                    patch_available=True,
                    mitigation='更新到Android 10或更高版本',
                    references=['https://source.android.com/security/bulletin/2019-10-01']
                ),
                SystemVulnerability(
                    cve_id='CVE-2020-0041',
                    name='Android binder驱动漏洞',
                    severity='HIGH',
                    cvss_score=6.7,
                    affected_versions=['< 11.0'],
                    description='binder驱动内存损坏漏洞，可能导致系统崩溃',
                    exploit_available=False,
                    patch_available=True,
                    mitigation='升级系统并限制应用权限',
                    references=['https://source.android.com/security/bulletin/2020-01-01']
                ),
                SystemVulnerability(
                    cve_id='CVE-2021-0920',
                    name='Android内核堆溢出漏洞',
                    severity='HIGH',
                    cvss_score=6.4,
                    affected_versions=['< 12.0'],
                    description='内核堆缓冲区溢出，可能导致任意代码执行',
                    exploit_available=True,
                    patch_available=True,
                    mitigation='安装最新安全补丁',
                    references=['https://source.android.com/security/bulletin/2021-12-01']
                ),
                SystemVulnerability(
                    cve_id='CVE-2022-20186',
                    name='Android框架漏洞',
                    severity='MEDIUM',
                    cvss_score=5.5,
                    affected_versions=['< 13.0'],
                    description='系统服务权限绞过漏洞',
                    exploit_available=False,
                    patch_available=True,
                    mitigation='更新系统并检查应用权限',
                    references=['https://source.android.com/security/bulletin/2022-06-01']
                )
            ],
            'kernel_vulnerabilities': [
                {
                    'name': 'Dirty COW',
                    'cve': 'CVE-2016-5195',
                    'severity': 'CRITICAL',
                    'description': 'Linux内核竞争条件漏洞',
                    'affected_kernels': ['< 4.8.3']
                },
                {
                    'name': 'KASLR Bypass',
                    'cve': 'CVE-2017-1000',
                    'severity': 'MEDIUM', 
                    'description': '内核地址空间随机化绞过',
                    'affected_kernels': ['< 4.14']
                }
            ],
            'config_vulnerabilities': [
                {
                    'check': 'adb_enabled',
                    'severity': 'MEDIUM',
                    'description': 'ADB调试功能已启用',
                    'risk_level': 0.6,
                    'mitigation': '关闭ADB调试模式'
                },
                {
                    'check': 'unknown_sources',
                    'severity': 'HIGH',
                    'description': '允许安装未知来源应用',
                    'risk_level': 0.8,
                    'mitigation': '禁用未知来源安装'
                },
                {
                    'check': 'developer_options',
                    'severity': 'LOW',
                    'description': '开发者选项已启用',
                    'risk_level': 0.3,
                    'mitigation': '关闭开发者选项'
                },
                {
                    'check': 'usb_debugging',
                    'severity': 'MEDIUM',
                    'description': 'USB调试已启用',
                    'risk_level': 0.5,
                    'mitigation': '关闭USB调试功能'
                },
                {
                    'check': 'root_access',
                    'severity': 'CRITICAL',
                    'description': '设备已ROOT',
                    'risk_level': 0.9,
                    'mitigation': '移除ROOT权限或加强安全措施'
                },
                {
                    'check': 'selinux_disabled',
                    'severity': 'HIGH',
                    'description': 'SELinux已禁用',
                    'risk_level': 0.8,
                    'mitigation': '启用SELinux强制模式'
                }
            ]
        }
    
    def _load_kernel_exploits(self) -> Dict[str, Any]:
        """加载内核漏洞利用信息"""
        return {
            'known_exploits': [
                {
                    'name': 'get_root',
                    'description': '通用ROOT工具',
                    'target_versions': ['< 9.0'],
                    'detection_patterns': ['get_root', 'su binary', 'supersu']
                },
                {
                    'name': 'towelroot',
                    'description': 'CVE-2014-3153利用工具',
                    'target_versions': ['< 5.0'],
                    'detection_patterns': ['towelroot', 'geohot']
                },
                {
                    'name': 'dirtycow',
                    'description': 'CVE-2016-5195利用工具',
                    'target_versions': ['< 7.0'],
                    'detection_patterns': ['dirtycow', 'dirty_cow']
                }
            ]
        }
    
    def _load_security_patches(self) -> Dict[str, Any]:
        """加载安全补丁信息"""
        return {
            'monthly_patches': {
                '2024-01': {
                    'patch_level': '2024-01-01',
                    'fixes': ['CVE-2023-40088', 'CVE-2023-40089'],
                    'severity': 'HIGH'
                },
                '2023-12': {
                    'patch_level': '2023-12-01', 
                    'fixes': ['CVE-2023-35674', 'CVE-2023-35675'],
                    'severity': 'CRITICAL'
                }
            }
        }


class VulnerabilityScanner(LoggerMixin):
    """漏洞扫描器"""
    
    def __init__(self, device_manager: DeviceManager):
        self.device_manager = device_manager
        self.vuln_db = VulnerabilityDatabase()
    
    def scan_system_vulnerabilities(self, device_id: str) -> List[Dict[str, Any]]:
        """扫描系统漏洞"""
        vulnerabilities = []
        
        try:
            # 获取Android版本
            android_version = self._get_android_version(device_id)
            
            # 检查已知系统漏洞
            for vuln in self.vuln_db.vulnerabilities['system_vulnerabilities']:
                if self._is_vulnerable(android_version, vuln['affected_versions']):
                    vulnerabilities.append({
                        'vuln_id': vuln['id'],
                        'name': vuln['name'],
                        'severity': vuln['severity'],
                        'description': vuln['description'],
                        'type': 'SYSTEM'
                    })
            
        except Exception as e:
            self.logger.error(f"系统漏洞扫描失败: {e}")
        
        return vulnerabilities
    
    def scan_configuration_issues(self, device_id: str) -> List[Dict[str, Any]]:
        """扫描配置问题"""
        issues = []
        
        try:
            # 检查ADB状态
            if self._check_adb_enabled(device_id):
                issues.append({
                    'name': 'ADB调试已启用',
                    'severity': 'MEDIUM',
                    'description': 'ADB调试功能存在安全风险',
                    'type': 'CONFIG'
                })
            
            # 检查未知来源安装
            if self._check_unknown_sources(device_id):
                issues.append({
                    'name': '允许未知来源安装',
                    'severity': 'HIGH', 
                    'description': '允许安装未验证的应用',
                    'type': 'CONFIG'
                })
        
        except Exception as e:
            self.logger.error(f"配置检查失败: {e}")
        
        return issues
    
    def _get_android_version(self, device_id: str) -> str:
        """获取Android版本"""
        result = self.device_manager.execute_command(  # pyright: ignore[reportAttributeAccessIssue]
            device_id, "getprop ro.build.version.release"
        )
        return result.strip() if result else "unknown"
    
    def _is_vulnerable(self, current_version: str, affected_versions: List[str]) -> bool:
        """检查版本是否存在漏洞"""
        try:
            current = float(current_version.split('.')[0])
            for version_range in affected_versions:
                if '<' in version_range:
                    max_version = float(version_range.replace('<', '').strip())
                    if current < max_version:
                        return True
        except:
            pass
        return False
    
    def _check_adb_enabled(self, device_id: str) -> bool:
        """检查ADB是否启用"""
        result = self.device_manager.execute_command(  # pyright: ignore[reportAttributeAccessIssue]
            device_id, "getprop service.adb.root"
        )
        return result and result.strip() == "1"
    
    def _check_unknown_sources(self, device_id: str) -> bool:
        """检查未知来源安装是否允许"""
        result = self.device_manager.execute_command(  # pyright: ignore[reportAttributeAccessIssue]
            device_id, "settings get global install_non_market_apps"
        )
        return result and result.strip() == "1"


class VulnerabilityDetectionEngine(LoggerMixin):
    """漏洞检测引擎"""
    
    def __init__(self, device_manager: DeviceManager):
        self.device_manager = device_manager
        self.scanner = VulnerabilityScanner(device_manager)
    
    def scan_vulnerabilities(self, device_id: str) -> Optional[VulnerabilityReport]:
        """扫描设备漏洞"""
        try:
            # 扫描系统漏洞
            system_vulns = self.scanner.scan_system_vulnerabilities(device_id)
            
            # 扫描配置问题
            config_issues = self.scanner.scan_configuration_issues(device_id)
            
            # 合并所有漏洞
            all_vulnerabilities = system_vulns + config_issues
            
            # 计算风险等级
            risk_level = self._calculate_risk_level(all_vulnerabilities)
            
            return VulnerabilityReport(
                device_id=device_id,
                vulnerability_count=len(all_vulnerabilities),
                critical_count=len([v for v in all_vulnerabilities if v['severity'] == 'CRITICAL']),
                high_count=len([v for v in all_vulnerabilities if v['severity'] == 'HIGH']),
                medium_count=len([v for v in all_vulnerabilities if v['severity'] == 'MEDIUM']),
                low_count=len([v for v in all_vulnerabilities if v['severity'] == 'LOW']),
                risk_level=risk_level,
                vulnerabilities=all_vulnerabilities,
                scan_summary={
                    'scan_time': datetime.now(),
                    'total_checks': len(system_vulns) + len(config_issues)
                }
            )
            
        except Exception as e:
            self.logger.error(f"漏洞扫描失败: {e}")
            return None
    
    def _calculate_risk_level(self, vulnerabilities: List[Dict[str, Any]]) -> ThreatLevel:
        """计算风险等级"""
        if any(v['severity'] == 'CRITICAL' for v in vulnerabilities):
            return ThreatLevel.CRITICAL
        elif any(v['severity'] == 'HIGH' for v in vulnerabilities):
            return ThreatLevel.HIGH
        elif any(v['severity'] == 'MEDIUM' for v in vulnerabilities):
            return ThreatLevel.MEDIUM
        else:
            return ThreatLevel.LOW