#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
漏洞扫描器 - CVE数据库集成、版本比较和漏洞识别
"""

import json
import time
import requests
from typing import List, Dict, Optional, Any, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
import re

from ..utils.logger import LoggerMixin


class VulnerabilityType(Enum):
    """漏洞类型"""
    BUFFER_OVERFLOW = "BUFFER_OVERFLOW"
    CODE_INJECTION = "CODE_INJECTION"
    PRIVILEGE_ESCALATION = "PRIVILEGE_ESCALATION"
    INFORMATION_DISCLOSURE = "INFORMATION_DISCLOSURE"
    DENIAL_OF_SERVICE = "DENIAL_OF_SERVICE"
    AUTHENTICATION_BYPASS = "AUTHENTICATION_BYPASS"
    PERMISSION_BYPASS = "PERMISSION_BYPASS"
    CRYPTO_WEAKNESS = "CRYPTO_WEAKNESS"
    CONFIGURATION_ERROR = "CONFIGURATION_ERROR"
    INPUT_VALIDATION = "INPUT_VALIDATION"


class SeverityLevel(Enum):
    """严重程度级别"""
    CRITICAL = "CRITICAL"    # 9.0-10.0
    HIGH = "HIGH"           # 7.0-8.9
    MEDIUM = "MEDIUM"       # 4.0-6.9
    LOW = "LOW"             # 0.1-3.9
    NONE = "NONE"           # 0.0


@dataclass
class VulnerabilityInfo:
    """漏洞信息"""
    vulnerability_id: str
    cve_id: str
    title: str
    description: str
    vulnerability_type: VulnerabilityType
    severity_level: SeverityLevel
    cvss_score: float
    cvss_vector: str
    affected_component: str
    affected_version: str
    fixed_version: Optional[str] = None
    patch_available: bool = False
    exploit_available: bool = False
    published_date: Optional[datetime] = None
    last_modified: Optional[datetime] = None
    references: List[str] = field(default_factory=list)
    cwe_id: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class VulnerabilityReport:
    """漏洞扫描报告"""
    scan_id: str
    device_id: str
    scan_time: datetime
    vulnerabilities: List[VulnerabilityInfo] = field(default_factory=list)
    total_vulnerabilities: int = 0
    critical_count: int = 0
    high_count: int = 0
    medium_count: int = 0
    low_count: int = 0
    patched_count: int = 0
    unpatched_count: int = 0
    scan_duration: float = 0.0
    metadata: Dict[str, Any] = field(default_factory=dict)


class CVEDatabase(LoggerMixin):
    """CVE数据库管理"""
    
    def __init__(self, db_path: str = "data/cve_database"):
        self.db_path = Path(db_path)
        self.db_path.mkdir(parents=True, exist_ok=True)
        
        # CVE数据库配置
        self.config = {
            'cve_api_url': 'https://services.nvd.nist.gov/rest/json/cves/2.0',
            'update_interval_hours': 24,
            'max_cve_age_days': 365,
            'android_keywords': ['android', 'qualcomm', 'samsung', 'mediatek'],
            'batch_size': 100
        }
        
        # 本地CVE数据库
        self.cve_data: Dict[str, Dict] = {}
        self.android_cves: Dict[str, VulnerabilityInfo] = {}
        
        # 数据库文件
        self.cve_db_file = self.db_path / "cve_database.json"
        self.android_cve_file = self.db_path / "android_cves.json"
        self.last_update_file = self.db_path / "last_update.json"
        
        # 加载现有数据
        self._load_cve_database()
    
    def _load_cve_database(self):
        """加载CVE数据库"""
        try:
            # 加载Android相关CVE
            if self.android_cve_file.exists():
                with open(self.android_cve_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                for cve_data in data.get('vulnerabilities', []):
                    vuln = VulnerabilityInfo(
                        vulnerability_id=cve_data['vulnerability_id'],
                        cve_id=cve_data['cve_id'],
                        title=cve_data['title'],
                        description=cve_data['description'],
                        vulnerability_type=VulnerabilityType(cve_data['vulnerability_type']),
                        severity_level=SeverityLevel(cve_data['severity_level']),
                        cvss_score=cve_data['cvss_score'],
                        cvss_vector=cve_data.get('cvss_vector', ''),
                        affected_component=cve_data['affected_component'],
                        affected_version=cve_data['affected_version'],
                        fixed_version=cve_data.get('fixed_version'),
                        patch_available=cve_data.get('patch_available', False),
                        exploit_available=cve_data.get('exploit_available', False),
                        published_date=datetime.fromisoformat(cve_data['published_date']) if cve_data.get('published_date') else None,
                        last_modified=datetime.fromisoformat(cve_data['last_modified']) if cve_data.get('last_modified') else None,
                        references=cve_data.get('references', []),
                        cwe_id=cve_data.get('cwe_id'),
                        metadata=cve_data.get('metadata', {})
                    )
                    self.android_cves[vuln.cve_id] = vuln
                
                self.logger.info(f"加载Android CVE数据库: {len(self.android_cves)} 个漏洞")
        
        except Exception as e:
            self.logger.error(f"加载CVE数据库失败: {e}")
    
    def update_cve_database(self) -> bool:
        """更新CVE数据库"""
        try:
            self.logger.info("开始更新CVE数据库...")
            
            # 检查是否需要更新
            if not self._should_update():
                self.logger.info("CVE数据库无需更新")
                return True
            
            # 获取最新CVE数据
            updated_count = 0
            
            # 搜索Android相关CVE
            for keyword in self.config['android_keywords']:
                cves = self._fetch_cves_by_keyword(keyword)
                for cve_data in cves:
                    if self._process_cve_data(cve_data):
                        updated_count += 1
            
            # 保存更新的数据库
            self._save_android_cves()
            self._update_last_update_time()
            
            self.logger.info(f"CVE数据库更新完成，新增/更新 {updated_count} 个漏洞")
            return True
        
        except Exception as e:
            self.logger.error(f"更新CVE数据库失败: {e}")
            return False
    
    def _should_update(self) -> bool:
        """检查是否需要更新"""
        try:
            if not self.last_update_file.exists():
                return True
            
            with open(self.last_update_file, 'r') as f:
                data = json.load(f)
            
            last_update = datetime.fromisoformat(data['last_update'])
            update_interval = timedelta(hours=self.config['update_interval_hours'])
            
            return datetime.now() - last_update > update_interval
        
        except:
            return True
    
    def _fetch_cves_by_keyword(self, keyword: str) -> List[Dict]:
        """根据关键字获取CVE数据"""
        try:
            # 构造API请求参数
            params = {
                'keywordSearch': keyword,
                'resultsPerPage': self.config['batch_size'],
                'startIndex': 0
            }
            
            # 时间范围过滤（最近一年）
            end_date = datetime.now()
            start_date = end_date - timedelta(days=self.config['max_cve_age_days'])
            params['pubStartDate'] = start_date.strftime('%Y-%m-%dT%H:%M:%S.000')
            params['pubEndDate'] = end_date.strftime('%Y-%m-%dT%H:%M:%S.000')
            
            response = requests.get(self.config['cve_api_url'], params=params, timeout=30)
            
            if response.status_code == 200:
                data = response.json()
                vulnerabilities = data.get('vulnerabilities', [])
                
                self.logger.info(f"获取到 {len(vulnerabilities)} 个 {keyword} 相关CVE")
                return vulnerabilities
            else:
                self.logger.error(f"CVE API请求失败: {response.status_code}")
                return []
        
        except Exception as e:
            self.logger.error(f"获取CVE数据失败: {e}")
            return []
    
    def _process_cve_data(self, cve_data: Dict) -> bool:
        """处理CVE数据"""
        try:
            cve = cve_data.get('cve', {})
            cve_id = cve.get('id', '')
            
            if not cve_id:
                return False
            
            # 解析基本信息
            descriptions = cve.get('descriptions', [])
            description = ""
            for desc in descriptions:
                if desc.get('lang') == 'en':
                    description = desc.get('value', '')
                    break
            
            # 解析CVSS评分
            metrics = cve.get('metrics', {})
            cvss_score = 0.0
            cvss_vector = ""
            
            # 优先使用CVSS v3
            if 'cvssMetricV31' in metrics:
                cvss_data = metrics['cvssMetricV31'][0]['cvssData']
                cvss_score = cvss_data.get('baseScore', 0.0)
                cvss_vector = cvss_data.get('vectorString', '')
            elif 'cvssMetricV30' in metrics:
                cvss_data = metrics['cvssMetricV30'][0]['cvssData']
                cvss_score = cvss_data.get('baseScore', 0.0)
                cvss_vector = cvss_data.get('vectorString', '')
            elif 'cvssMetricV2' in metrics:
                cvss_data = metrics['cvssMetricV2'][0]['cvssData']
                cvss_score = cvss_data.get('baseScore', 0.0)
                cvss_vector = cvss_data.get('vectorString', '')
            
            # 确定严重程度
            severity_level = self._score_to_severity(cvss_score)
            
            # 解析受影响的配置
            configurations = cve.get('configurations', [])
            affected_component = "Android"
            affected_version = "Unknown"
            
            for config in configurations:
                nodes = config.get('nodes', [])
                for node in nodes:
                    cpe_matches = node.get('cpeMatch', [])
                    for cpe_match in cpe_matches:
                        cpe23_uri = cpe_match.get('criteria', '')
                        if 'android' in cpe23_uri.lower():
                            affected_component, affected_version = self._parse_cpe(cpe23_uri)
                            break
            
            # 解析CWE信息
            weaknesses = cve.get('weaknesses', [])
            cwe_id = None
            vuln_type = VulnerabilityType.INFORMATION_DISCLOSURE  # 默认类型
            
            for weakness in weaknesses:
                descriptions = weakness.get('description', [])
                for desc in descriptions:
                    if desc.get('lang') == 'en':
                        cwe_value = desc.get('value', '')
                        if cwe_value.startswith('CWE-'):
                            cwe_id = cwe_value
                            vuln_type = self._cwe_to_vulnerability_type(cwe_value)
                            break
            
            # 解析参考链接
            references = []
            ref_data = cve.get('references', [])
            for ref in ref_data:
                references.append(ref.get('url', ''))
            
            # 解析发布时间
            published_date = None
            last_modified = None
            
            if 'published' in cve:
                published_date = datetime.fromisoformat(cve['published'].replace('Z', '+00:00'))
            
            if 'lastModified' in cve:
                last_modified = datetime.fromisoformat(cve['lastModified'].replace('Z', '+00:00'))
            
            # 创建漏洞信息对象
            vulnerability = VulnerabilityInfo(
                vulnerability_id=f"vuln_{int(time.time())}_{len(self.android_cves)}",
                cve_id=cve_id,
                title=f"Android漏洞 - {cve_id}",
                description=description,
                vulnerability_type=vuln_type,
                severity_level=severity_level,
                cvss_score=cvss_score,
                cvss_vector=cvss_vector,
                affected_component=affected_component,
                affected_version=affected_version,
                references=references,
                cwe_id=cwe_id,
                published_date=published_date,
                last_modified=last_modified,
                metadata={
                    'source': 'NVD',
                    'raw_data': cve_data
                }
            )
            
            # 添加到数据库
            self.android_cves[cve_id] = vulnerability
            
            return True
        
        except Exception as e:
            self.logger.error(f"处理CVE数据失败: {e}")
            return False
    
    def _score_to_severity(self, cvss_score: float) -> SeverityLevel:
        """CVSS评分转严重程度"""
        if cvss_score >= 9.0:
            return SeverityLevel.CRITICAL
        elif cvss_score >= 7.0:
            return SeverityLevel.HIGH
        elif cvss_score >= 4.0:
            return SeverityLevel.MEDIUM
        elif cvss_score > 0.0:
            return SeverityLevel.LOW
        else:
            return SeverityLevel.NONE
    
    def _parse_cpe(self, cpe_uri: str) -> Tuple[str, str]:
        """解析CPE URI"""
        try:
            # CPE格式: cpe:2.3:o:google:android:version:*:*:*:*:*:*:*
            parts = cpe_uri.split(':')
            if len(parts) >= 6:
                vendor = parts[3]
                product = parts[4]
                version = parts[5]
                
                component = f"{vendor} {product}"
                return component, version
        except:
            pass
        
        return "Android", "Unknown"
    
    def _cwe_to_vulnerability_type(self, cwe_id: str) -> VulnerabilityType:
        """CWE ID转漏洞类型"""
        cwe_mapping = {
            'CWE-119': VulnerabilityType.BUFFER_OVERFLOW,
            'CWE-120': VulnerabilityType.BUFFER_OVERFLOW,
            'CWE-78': VulnerabilityType.CODE_INJECTION,
            'CWE-79': VulnerabilityType.CODE_INJECTION,
            'CWE-264': VulnerabilityType.PRIVILEGE_ESCALATION,
            'CWE-269': VulnerabilityType.PRIVILEGE_ESCALATION,
            'CWE-200': VulnerabilityType.INFORMATION_DISCLOSURE,
            'CWE-399': VulnerabilityType.DENIAL_OF_SERVICE,
            'CWE-287': VulnerabilityType.AUTHENTICATION_BYPASS,
            'CWE-732': VulnerabilityType.PERMISSION_BYPASS,
            'CWE-310': VulnerabilityType.CRYPTO_WEAKNESS,
            'CWE-16': VulnerabilityType.CONFIGURATION_ERROR,
            'CWE-20': VulnerabilityType.INPUT_VALIDATION
        }
        
        return cwe_mapping.get(cwe_id, VulnerabilityType.INFORMATION_DISCLOSURE)
    
    def _save_android_cves(self):
        """保存Android CVE数据"""
        try:
            data = {
                'version': '1.0',
                'updated': datetime.now().isoformat(),
                'total_vulnerabilities': len(self.android_cves),
                'vulnerabilities': []
            }
            
            for vuln in self.android_cves.values():
                vuln_data = {
                    'vulnerability_id': vuln.vulnerability_id,
                    'cve_id': vuln.cve_id,
                    'title': vuln.title,
                    'description': vuln.description,
                    'vulnerability_type': vuln.vulnerability_type.value,
                    'severity_level': vuln.severity_level.value,
                    'cvss_score': vuln.cvss_score,
                    'cvss_vector': vuln.cvss_vector,
                    'affected_component': vuln.affected_component,
                    'affected_version': vuln.affected_version,
                    'fixed_version': vuln.fixed_version,
                    'patch_available': vuln.patch_available,
                    'exploit_available': vuln.exploit_available,
                    'published_date': vuln.published_date.isoformat() if vuln.published_date else None,
                    'last_modified': vuln.last_modified.isoformat() if vuln.last_modified else None,
                    'references': vuln.references,
                    'cwe_id': vuln.cwe_id,
                    'metadata': vuln.metadata
                }
                data['vulnerabilities'].append(vuln_data)
            
            with open(self.android_cve_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        
        except Exception as e:
            self.logger.error(f"保存Android CVE数据失败: {e}")
    
    def _update_last_update_time(self):
        """更新最后更新时间"""
        try:
            data = {
                'last_update': datetime.now().isoformat(),
                'total_cves': len(self.android_cves)
            }
            
            with open(self.last_update_file, 'w') as f:
                json.dump(data, f, indent=2)
        
        except Exception as e:
            self.logger.error(f"更新时间戳失败: {e}")
    
    def search_vulnerabilities(self, component: str = "", version: str = "", 
                             severity: Optional[SeverityLevel] = None) -> List[VulnerabilityInfo]:
        """搜索漏洞"""
        results = []
        
        for vuln in self.android_cves.values():
            # 组件匹配
            if component and component.lower() not in vuln.affected_component.lower():
                continue
            
            # 版本匹配
            if version and not self._version_affected(vuln.affected_version, version):
                continue
            
            # 严重程度匹配
            if severity and vuln.severity_level != severity:
                continue
            
            results.append(vuln)
        
        return results
    
    def _version_affected(self, affected_version: str, current_version: str) -> bool:
        """检查版本是否受影响"""
        try:
            # 简化的版本比较逻辑
            if affected_version == "Unknown" or affected_version == "*":
                return True
            
            # 如果受影响版本包含范围标识符
            if '<' in affected_version or '>' in affected_version:
                return self._compare_version_range(affected_version, current_version)  # pyright: ignore[reportAttributeAccessIssue]
            
            # 直接版本比较
            return self._compare_versions(current_version, affected_version) >= 0  # pyright: ignore[reportAttributeAccessIssue]
        
        except:
            return True  # 无法确定时默认受影响


class VulnerabilityScanner(LoggerMixin):
    """漏洞扫描器"""
    
    def __init__(self, cve_database: CVEDatabase = None):  # pyright: ignore[reportArgumentType]
        self.cve_database = cve_database or CVEDatabase()
        
        # 扫描配置
        self.config = {
            'scan_timeout': 600,
            'max_vulnerabilities': 1000,
            'severity_filter': [SeverityLevel.CRITICAL, SeverityLevel.HIGH, SeverityLevel.MEDIUM],
            'component_scan_enabled': True,
            'version_check_enabled': True
        }
    
    def scan_device_vulnerabilities(self, device_manager, device_id: str) -> Optional[VulnerabilityReport]:
        """扫描设备漏洞"""
        try:
            self.logger.info(f"开始设备漏洞扫描: {device_id}")
            
            scan_id = f"vuln_scan_{device_id}_{int(time.time())}"
            start_time = time.time()
            
            # 获取设备信息
            device_info = device_manager.get_device(device_id)
            if not device_info:
                self.logger.error(f"设备未找到: {device_id}")
                return None
            
            # 获取系统信息
            system_info = self._get_system_info(device_manager, device_id)
            
            # 搜索相关漏洞
            vulnerabilities = []
            
            # 基于Android版本搜索
            android_version = system_info.get('android_version', '')
            if android_version:
                android_vulns = self.cve_database.search_vulnerabilities(
                    component="android", 
                    version=android_version
                )
                vulnerabilities.extend(android_vulns)
            
            # 基于厂商信息搜索
            brand = system_info.get('brand', '')
            if brand:
                brand_vulns = self.cve_database.search_vulnerabilities(component=brand.lower())
                vulnerabilities.extend(brand_vulns)
            
            # 过滤严重程度
            filtered_vulns = [
                v for v in vulnerabilities 
                if v.severity_level in self.config['severity_filter']
            ]
            
            # 去重
            unique_vulns = {}
            for vuln in filtered_vulns:
                unique_vulns[vuln.cve_id] = vuln
            
            final_vulnerabilities = list(unique_vulns.values())
            
            # 生成报告
            report = VulnerabilityReport(
                scan_id=scan_id,
                device_id=device_id,
                scan_time=datetime.now(),
                vulnerabilities=final_vulnerabilities,
                total_vulnerabilities=len(final_vulnerabilities),
                scan_duration=time.time() - start_time,
                metadata={
                    'system_info': system_info,
                    'scanner_version': '1.0'
                }
            )
            
            # 统计各级别漏洞
            self._calculate_vulnerability_stats(report)
            
            self.logger.info(f"漏洞扫描完成: 发现 {len(final_vulnerabilities)} 个漏洞")
            return report
        
        except Exception as e:
            self.logger.error(f"设备漏洞扫描失败: {e}")
            return None
    
    def _get_system_info(self, device_manager, device_id: str) -> Dict[str, str]:
        """获取系统信息"""
        try:
            system_info = {}
            
            # 获取Android版本
            android_version = device_manager.adb_manager.execute_command(
                device_id, "getprop ro.build.version.release"
            )
            if android_version:
                system_info['android_version'] = android_version.strip()
            
            # 获取品牌信息
            brand = device_manager.adb_manager.execute_command(
                device_id, "getprop ro.product.brand"
            )
            if brand:
                system_info['brand'] = brand.strip()
            
            # 获取型号信息
            model = device_manager.adb_manager.execute_command(
                device_id, "getprop ro.product.model"
            )
            if model:
                system_info['model'] = model.strip()
            
            # 获取安全补丁级别
            security_patch = device_manager.adb_manager.execute_command(
                device_id, "getprop ro.build.version.security_patch"
            )
            if security_patch:
                system_info['security_patch'] = security_patch.strip()
            
            # 获取API级别
            api_level = device_manager.adb_manager.execute_command(
                device_id, "getprop ro.build.version.sdk"
            )
            if api_level:
                system_info['api_level'] = api_level.strip()
            
            return system_info
        
        except Exception as e:
            self.logger.error(f"获取系统信息失败: {e}")
            return {}
    
    def _calculate_vulnerability_stats(self, report: VulnerabilityReport):
        """计算漏洞统计信息"""
        for vuln in report.vulnerabilities:
            if vuln.severity_level == SeverityLevel.CRITICAL:
                report.critical_count += 1
            elif vuln.severity_level == SeverityLevel.HIGH:
                report.high_count += 1
            elif vuln.severity_level == SeverityLevel.MEDIUM:
                report.medium_count += 1
            elif vuln.severity_level == SeverityLevel.LOW:
                report.low_count += 1
            
            if vuln.patch_available:
                report.patched_count += 1
            else:
                report.unpatched_count += 1
    
    def _compare_versions(self, version1: str, version2: str) -> int:
        """比较版本号"""
        try:
            # 简化的版本比较
            v1_parts = [int(x) for x in version1.split('.')]
            v2_parts = [int(x) for x in version2.split('.')]
            
            # 补齐长度
            max_len = max(len(v1_parts), len(v2_parts))
            v1_parts.extend([0] * (max_len - len(v1_parts)))
            v2_parts.extend([0] * (max_len - len(v2_parts)))
            
            for i in range(max_len):
                if v1_parts[i] > v2_parts[i]:
                    return 1
                elif v1_parts[i] < v2_parts[i]:
                    return -1
            
            return 0
        except:
            return 0
    
    def _compare_version_range(self, range_expr: str, version: str) -> bool:
        """比较版本范围"""
        try:
            # 简化处理，实际实现需要更复杂的版本范围解析
            if '<' in range_expr:
                max_version = range_expr.split('<')[1].strip()
                return self._compare_versions(version, max_version) < 0
            elif '>' in range_expr:
                min_version = range_expr.split('>')[1].strip()
                return self._compare_versions(version, min_version) > 0
            
            return True
        except:
            return True
    
    def update_vulnerability_database(self) -> bool:
        """更新漏洞数据库"""
        return self.cve_database.update_cve_database()
    
    def get_vulnerability_statistics(self) -> Dict[str, Any]:
        """获取漏洞统计信息"""
        total_vulns = len(self.cve_database.android_cves)
        
        severity_counts = {}
        for severity in SeverityLevel:
            count = sum(1 for v in self.cve_database.android_cves.values() 
                       if v.severity_level == severity)
            severity_counts[severity.value] = count
        
        return {
            'total_vulnerabilities': total_vulns,
            'severity_counts': severity_counts,
            'last_update': self._get_last_update_time(),
            'database_path': str(self.cve_database.db_path)
        }
    
    def _get_last_update_time(self) -> Optional[str]:
        """获取最后更新时间"""
        try:
            if self.cve_database.last_update_file.exists():
                with open(self.cve_database.last_update_file, 'r') as f:
                    data = json.load(f)
                    return data.get('last_update')
        except:
            pass
        return None