#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
系统漏洞扫描和内核安全检测扩展模块
"""

import re
import subprocess
from typing import Dict, List, Optional, Any
from datetime import datetime

from ..utils.logger import LoggerMixin
from .device_manager import DeviceManager


class KernelSecurityScanner(LoggerMixin):
    """内核安全扫描器"""
    
    def __init__(self, device_manager: DeviceManager):
        self.device_manager = device_manager
        
    def scan_kernel_security(self, device_id: str) -> Dict[str, Any]:
        """扫描内核安全状态"""
        try:
            security_info = {
                'kernel_version': self._get_kernel_version(device_id),
                'selinux_status': self._check_selinux_status(device_id),
                'aslr_enabled': self._check_aslr_enabled(device_id),
                'stack_protection': self._check_stack_protection(device_id),
                'kernel_guards': self._check_kernel_guards(device_id),
                'root_status': self._check_root_status(device_id),
                'security_features': self._check_security_features(device_id)
            }
            
            # 评估安全等级
            security_info['security_level'] = self._evaluate_security_level(security_info)
            
            return security_info
            
        except Exception as e:
            self.logger.error(f"内核安全扫描失败: {e}")
            return {'error': str(e)}
    
    def _get_kernel_version(self, device_id: str) -> str:
        """获取内核版本"""
        result = self.device_manager.execute_command(device_id, "uname -r")  # pyright: ignore[reportAttributeAccessIssue]
        return result.strip() if result else "unknown"
    
    def _check_selinux_status(self, device_id: str) -> Dict[str, Any]:
        """检查SELinux状态"""
        try:
            # 检查SELinux状态
            status_result = self.device_manager.execute_command(device_id, "getenforce")  # pyright: ignore[reportAttributeAccessIssue]
            policy_result = self.device_manager.execute_command(device_id, "getprop ro.build.selinux")  # pyright: ignore[reportAttributeAccessIssue]
            
            return {
                'status': status_result.strip() if status_result else 'unknown',
                'policy': policy_result.strip() if policy_result else 'unknown',
                'enabled': status_result and 'enforcing' in status_result.lower()
            }
        except:
            return {'status': 'unknown', 'enabled': False}
    
    def _check_aslr_enabled(self, device_id: str) -> bool:
        """检查地址空间布局随机化(ASLR)"""
        try:
            result = self.device_manager.execute_command(device_id, "cat /proc/sys/kernel/randomize_va_space")
            return result and result.strip() == '2'
        except:
            return False
    
    def _check_stack_protection(self, device_id: str) -> bool:
        """检查栈保护"""
        try:
            # 检查栈金丝雀保护
            result = self.device_manager.execute_command(device_id, "cat /proc/version")
            return result and 'stack-protector' in result.lower()
        except:
            return False
    
    def _check_kernel_guards(self, device_id: str) -> List[str]:
        """检查内核防护机制"""
        guards = []
        try:
            # 检查SMEP (Supervisor Mode Execution Prevention)
            if self._check_feature(device_id, "smep"):
                guards.append("SMEP")
            
            # 检查SMAP (Supervisor Mode Access Prevention)
            if self._check_feature(device_id, "smap"):
                guards.append("SMAP")
            
            # 检查KASLR (Kernel Address Space Layout Randomization)
            if self._check_feature(device_id, "kaslr"):
                guards.append("KASLR")
                
        except Exception as e:
            self.logger.error(f"内核防护检查失败: {e}")
        
        return guards
    
    def _check_feature(self, device_id: str, feature: str) -> bool:
        """检查特定安全特性"""
        try:
            result = self.device_manager.execute_command(device_id, f"cat /proc/cpuinfo | grep {feature}")
            return bool(result and result.strip())
        except:
            return False
    
    def _check_root_status(self, device_id: str) -> Dict[str, Any]:
        """检查Root状态"""
        try:
            # 检查su命令
            su_result = self.device_manager.execute_command(device_id, "which su")
            
            # 检查Magisk
            magisk_result = self.device_manager.execute_command(device_id, "getprop ro.magisk.version")
            
            # 检查SuperSU
            supersu_result = self.device_manager.execute_command(device_id, "ls /system/app/SuperSU")
            
            is_rooted = bool(su_result or magisk_result or supersu_result)
            
            root_info = {
                'is_rooted': is_rooted,
                'su_available': bool(su_result),
                'magisk_detected': bool(magisk_result),
                'supersu_detected': bool(supersu_result),
                'root_method': 'unknown'
            }
            
            if magisk_result:
                root_info['root_method'] = 'magisk'
            elif supersu_result:
                root_info['root_method'] = 'supersu'
            elif su_result:
                root_info['root_method'] = 'generic_su'
            
            return root_info
            
        except Exception as e:
            self.logger.error(f"Root状态检查失败: {e}")
            return {'is_rooted': False, 'error': str(e)}
    
    def _check_security_features(self, device_id: str) -> Dict[str, bool]:
        """检查安全特性"""
        features = {}
        
        try:
            # 检查安全启动
            secure_boot = self.device_manager.execute_command(device_id, "getprop ro.boot.verifiedbootstate")
            features['secure_boot'] = secure_boot and 'green' in secure_boot.lower()
            
            # 检查设备加密
            encryption = self.device_manager.execute_command(device_id, "getprop ro.crypto.state")
            features['encryption'] = encryption and 'encrypted' in encryption.lower()
            
            # 检查锁屏安全
            lockscreen = self.device_manager.execute_command(device_id, "dumpsys device_policy | grep PasswordQuality")
            features['lockscreen_security'] = bool(lockscreen)
            
            # 检查应用签名验证
            verify_apps = self.device_manager.execute_command(device_id, "settings get global package_verifier_enable")
            features['app_verification'] = verify_apps and verify_apps.strip() == '1'
            
        except Exception as e:
            self.logger.error(f"安全特性检查失败: {e}")
        
        return features
    
    def _evaluate_security_level(self, security_info: Dict[str, Any]) -> str:
        """评估安全等级"""
        try:
            score = 0
            max_score = 10
            
            # SELinux评分
            if security_info.get('selinux_status', {}).get('enabled', False):
                score += 2
            
            # ASLR评分
            if security_info.get('aslr_enabled', False):
                score += 2
            
            # 内核防护评分
            guards_count = len(security_info.get('kernel_guards', []))
            score += min(guards_count, 2)
            
            # Root状态评分（未Root加分）
            if not security_info.get('root_status', {}).get('is_rooted', True):
                score += 2
            
            # 安全特性评分
            security_features = security_info.get('security_features', {})
            enabled_features = sum(1 for enabled in security_features.values() if enabled)
            score += min(enabled_features // 2, 2)
            
            # 计算安全等级
            security_ratio = score / max_score
            
            if security_ratio >= 0.8:
                return 'EXCELLENT'
            elif security_ratio >= 0.6:
                return 'GOOD'
            elif security_ratio >= 0.4:
                return 'FAIR'
            else:
                return 'POOR'
                
        except Exception as e:
            self.logger.error(f"安全等级评估失败: {e}")
            return 'UNKNOWN'


class SystemVulnerabilityScanner(LoggerMixin):
    """系统漏洞扫描器"""
    
    def __init__(self, device_manager: DeviceManager, vuln_db):
        self.device_manager = device_manager
        self.vuln_db = vuln_db
        
    def scan_system_vulnerabilities(self, device_id: str) -> List[Dict[str, Any]]:
        """扫描系统漏洞"""
        vulnerabilities = []
        
        try:
            # 获取系统信息
            system_info = self._get_system_info(device_id)
            
            # 检查已知系统漏洞
            for vuln in self.vuln_db.vulnerabilities['system_vulnerabilities']:
                if self._is_vulnerable(system_info, vuln):
                    vuln_dict = vuln.to_dict()
                    vuln_dict['detected'] = True
                    vuln_dict['system_info'] = system_info
                    vulnerabilities.append(vuln_dict)
            
            # 检查内核漏洞
            kernel_vulns = self._check_kernel_vulnerabilities(device_id, system_info)
            vulnerabilities.extend(kernel_vulns)
            
        except Exception as e:
            self.logger.error(f"系统漏洞扫描失败: {e}")
        
        return vulnerabilities
    
    def _get_system_info(self, device_id: str) -> Dict[str, str]:
        """获取系统信息"""
        try:
            return {
                'android_version': self._get_prop(device_id, 'ro.build.version.release'),
                'security_patch': self._get_prop(device_id, 'ro.build.version.security_patch'),
                'sdk_version': self._get_prop(device_id, 'ro.build.version.sdk'),
                'kernel_version': self._get_kernel_version(device_id),
                'build_fingerprint': self._get_prop(device_id, 'ro.build.fingerprint'),
                'manufacturer': self._get_prop(device_id, 'ro.product.manufacturer'),
                'model': self._get_prop(device_id, 'ro.product.model')
            }
        except Exception as e:
            self.logger.error(f"获取系统信息失败: {e}")
            return {}
    
    def _get_prop(self, device_id: str, prop_name: str) -> str:
        """获取系统属性"""
        result = self.device_manager.execute_command(device_id, f"getprop {prop_name}")
        return result.strip() if result else "unknown"
    
    def _get_kernel_version(self, device_id: str) -> str:
        """获取内核版本"""
        result = self.device_manager.execute_command(device_id, "uname -r")
        return result.strip() if result else "unknown"
    
    def _is_vulnerable(self, system_info: Dict[str, str], vuln) -> bool:
        """检查系统是否存在漏洞"""
        try:
            android_version = system_info.get('android_version', '0')
            security_patch = system_info.get('security_patch', '1970-01-01')
            
            # 检查Android版本
            for version_range in vuln.affected_versions:
                if self._version_matches(android_version, version_range):
                    # 进一步检查安全补丁级别
                    if not self._has_security_patch(security_patch, vuln.cve_id):
                        return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"漏洞匹配检查失败: {e}")
            return False
    
    def _version_matches(self, current_version: str, version_range: str) -> bool:
        """检查版本是否匹配漏洞影响范围"""
        try:
            if '<' in version_range:
                max_version = version_range.replace('<', '').strip()
                return float(current_version.split('.')[0]) < float(max_version.split('.')[0])
            elif '=' in version_range:
                target_version = version_range.replace('=', '').strip()
                return current_version.startswith(target_version)
            return False
        except:
            return False
    
    def _has_security_patch(self, patch_date: str, cve_id: str) -> bool:
        """检查是否已安装相关安全补丁"""
        try:
            # 简化实现，实际应该查询CVE修复的具体补丁日期
            patch_fixes = {
                'CVE-2019-2215': '2019-10-01',
                'CVE-2020-0041': '2020-01-01',
                'CVE-2021-0920': '2021-12-01',
                'CVE-2022-20186': '2022-06-01'
            }
            
            fix_date = patch_fixes.get(cve_id)
            if fix_date and patch_date >= fix_date:
                return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"安全补丁检查失败: {e}")
            return False
    
    def _check_kernel_vulnerabilities(self, device_id: str, system_info: Dict[str, str]) -> List[Dict[str, Any]]:
        """检查内核漏洞"""
        kernel_vulns = []
        
        try:
            kernel_version = system_info.get('kernel_version', '')
            
            for vuln in self.vuln_db.vulnerabilities.get('kernel_vulnerabilities', []):
                if self._kernel_vulnerable(kernel_version, vuln['affected_kernels']):
                    kernel_vulns.append({
                        'vuln_id': vuln['cve'],
                        'name': vuln['name'],
                        'severity': vuln['severity'],
                        'description': vuln['description'],
                        'type': 'KERNEL',
                        'kernel_version': kernel_version
                    })
                    
        except Exception as e:
            self.logger.error(f"内核漏洞检查失败: {e}")
        
        return kernel_vulns
    
    def _kernel_vulnerable(self, kernel_version: str, affected_kernels: List[str]) -> bool:
        """检查内核版本是否存在漏洞"""
        try:
            # 简化的版本比较
            current_version = kernel_version.split('-')[0]  # 去掉构建信息
            
            for version_range in affected_kernels:
                if '<' in version_range:
                    max_version = version_range.replace('<', '').strip()
                    if self._compare_kernel_version(current_version, max_version) < 0:
                        return True
            
            return False
            
        except Exception as e:
            self.logger.error(f"内核版本比较失败: {e}")
            return False
    
    def _compare_kernel_version(self, version1: str, version2: str) -> int:
        """比较内核版本号"""
        try:
            v1_parts = [int(x) for x in version1.split('.')]
            v2_parts = [int(x) for x in version2.split('.')]
            
            # 补齐版本号位数
            max_len = max(len(v1_parts), len(v2_parts))
            v1_parts.extend([0] * (max_len - len(v1_parts)))
            v2_parts.extend([0] * (max_len - len(v2_parts)))
            
            for i in range(max_len):
                if v1_parts[i] < v2_parts[i]:
                    return -1
                elif v1_parts[i] > v2_parts[i]:
                    return 1
            
            return 0
            
        except Exception as e:
            self.logger.error(f"版本比较失败: {e}")
            return 0