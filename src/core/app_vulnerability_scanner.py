#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
应用漏洞检测和配置安全评估模块
提供应用级安全扫描、权限分析和配置安全检查
"""

import json
import re
from typing import Dict, List, Optional, Any, Tuple
from datetime import datetime
from dataclasses import dataclass, field

from ..models import SecurityIndicator, IndicatorType, Severity
from ..utils.logger import LoggerMixin
from .device_manager import DeviceManager


@dataclass
class AppVulnerability:
    """应用漏洞信息"""
    app_package: str
    vuln_type: str
    severity: str
    description: str
    affected_components: List[str]
    exploit_risk: float
    mitigation: str
    cve_references: List[str] = field(default_factory=list)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'app_package': self.app_package,
            'vuln_type': self.vuln_type,
            'severity': self.severity,
            'description': self.description,
            'affected_components': self.affected_components,
            'exploit_risk': self.exploit_risk,
            'mitigation': self.mitigation,
            'cve_references': self.cve_references
        }


@dataclass
class ConfigurationIssue:
    """配置问题"""
    category: str
    issue_type: str
    severity: str
    description: str
    current_value: str
    recommended_value: str
    risk_level: float
    auto_fixable: bool = False


class ApplicationVulnerabilityScanner(LoggerMixin):
    """应用漏洞扫描器"""
    
    def __init__(self, device_manager: DeviceManager):
        self.device_manager = device_manager
        self.vulnerability_patterns = self._load_vulnerability_patterns()
        self.permission_risks = self._load_permission_risks()
        
    def _load_vulnerability_patterns(self) -> Dict[str, Any]:
        """加载应用漏洞模式"""
        return {
            'insecure_storage': {
                'patterns': [
                    r'SharedPreferences.*MODE_WORLD_READABLE',
                    r'SharedPreferences.*MODE_WORLD_WRITABLE',
                    r'openFileOutput.*MODE_WORLD_READABLE',
                    r'SQLiteDatabase.*WORLD_READABLE'
                ],
                'severity': 'HIGH',
                'description': '不安全的数据存储'
            },
            'insecure_communication': {
                'patterns': [
                    r'HttpURLConnection.*setHostnameVerifier.*ALLOW_ALL',
                    r'TrustManager.*checkServerTrusted.*return',
                    r'SSLSocketFactory.*ALLOW_ALL_HOSTNAME_VERIFIER',
                    r'http://.*api'
                ],
                'severity': 'MEDIUM',
                'description': '不安全的网络通信'
            },
            'crypto_weaknesses': {
                'patterns': [
                    r'Cipher\.getInstance\("DES"',
                    r'Cipher\.getInstance\("AES"',
                    r'MessageDigest\.getInstance\("MD5"',
                    r'MessageDigest\.getInstance\("SHA1"'
                ],
                'severity': 'MEDIUM',
                'description': '弱加密算法'
            },
            'code_injection': {
                'patterns': [
                    r'Runtime\.getRuntime\(\)\.exec',
                    r'ProcessBuilder.*start',
                    r'webView\.loadUrl\(.*\+',
                    r'addJavascriptInterface'
                ],
                'severity': 'HIGH',
                'description': '代码注入风险'
            },
            'intent_vulnerabilities': {
                'patterns': [
                    r'startActivity.*getIntent',
                    r'sendBroadcast.*new Intent',
                    r'PendingIntent\.getActivity.*0',
                    r'Intent.*setComponent'
                ],
                'severity': 'MEDIUM',
                'description': 'Intent安全问题'
            }
        }
    
    def _load_permission_risks(self) -> Dict[str, Dict[str, Any]]:
        """加载权限风险评估"""
        return {
            'android.permission.SEND_SMS': {
                'risk_level': 0.9,
                'category': '通信控制',
                'potential_abuse': '发送恶意短信、订阅付费服务'
            },
            'android.permission.CALL_PHONE': {
                'risk_level': 0.8,
                'category': '通话控制', 
                'potential_abuse': '拨打付费电话、骚扰电话'
            },
            'android.permission.RECORD_AUDIO': {
                'risk_level': 0.8,
                'category': '隐私窃取',
                'potential_abuse': '窃听用户对话、录音监控'
            },
            'android.permission.CAMERA': {
                'risk_level': 0.7,
                'category': '隐私窃取',
                'potential_abuse': '偷拍用户、远程监控'
            },
            'android.permission.ACCESS_FINE_LOCATION': {
                'risk_level': 0.8,
                'category': '位置追踪',
                'potential_abuse': '跟踪用户位置、泄露隐私'
            },
            'android.permission.READ_CONTACTS': {
                'risk_level': 0.7,
                'category': '数据窃取',
                'potential_abuse': '窃取联系人信息、传播病毒'
            },
            'android.permission.READ_SMS': {
                'risk_level': 0.8,
                'category': '隐私窃取',
                'potential_abuse': '读取验证码、窃取隐私信息'
            },
            'android.permission.DEVICE_ADMIN': {
                'risk_level': 0.9,
                'category': '系统控制',
                'potential_abuse': '锁定设备、远程擦除数据'
            },
            'android.permission.SYSTEM_ALERT_WINDOW': {
                'risk_level': 0.6,
                'category': '界面劫持',
                'potential_abuse': '钓鱼攻击、界面覆盖'
            }
        }
    
    def scan_application_vulnerabilities(self, device_id: str, app_package: str) -> List[AppVulnerability]:
        """扫描应用漏洞"""
        vulnerabilities = []
        
        try:
            # 获取应用信息
            app_info = self._get_application_info(device_id, app_package)
            
            # 扫描代码漏洞
            code_vulns = self._scan_code_vulnerabilities(app_package, app_info)
            vulnerabilities.extend(code_vulns)
            
            # 扫描权限滥用
            perm_vulns = self._scan_permission_abuse(app_package, app_info.get('permissions', []))
            vulnerabilities.extend(perm_vulns)
            
            # 扫描组件配置问题
            comp_vulns = self._scan_component_vulnerabilities(app_package, app_info)
            vulnerabilities.extend(comp_vulns)
            
        except Exception as e:
            self.logger.error(f"应用漏洞扫描失败 {app_package}: {e}")
        
        return vulnerabilities
    
    def _get_application_info(self, device_id: str, app_package: str) -> Dict[str, Any]:
        """获取应用详细信息"""
        try:
            app_info = {}
            
            # 获取应用基本信息
            result = self.device_manager.execute_command(device_id, f"dumpsys package {app_package}")
            if result:
                app_info['package_info'] = result
                
                # 解析权限
                permissions = re.findall(r'android\.permission\.[\w_]+', result)
                app_info['permissions'] = list(set(permissions))
                
                # 解析组件信息
                activities = re.findall(r'Activity.*?{.*?}', result, re.DOTALL)
                services = re.findall(r'Service.*?{.*?}', result, re.DOTALL)
                receivers = re.findall(r'Receiver.*?{.*?}', result, re.DOTALL)
                
                app_info['components'] = {
                    'activities': len(activities),
                    'services': len(services),  
                    'receivers': len(receivers)
                }
            
            # 获取APK路径
            path_result = self.device_manager.execute_command(device_id, f"pm path {app_package}")
            if path_result and path_result.startswith('package:'):
                app_info['apk_path'] = path_result.replace('package:', '').strip()
            
            return app_info
            
        except Exception as e:
            self.logger.error(f"获取应用信息失败 {app_package}: {e}")
            return {}
    
    def _scan_code_vulnerabilities(self, app_package: str, app_info: Dict[str, Any]) -> List[AppVulnerability]:
        """扫描代码漏洞"""
        vulnerabilities = []
        
        try:
            package_info = app_info.get('package_info', '')
            
            for vuln_type, pattern_info in self.vulnerability_patterns.items():
                for pattern in pattern_info['patterns']:
                    if re.search(pattern, package_info, re.IGNORECASE):
                        vulnerabilities.append(AppVulnerability(
                            app_package=app_package,
                            vuln_type=vuln_type,
                            severity=pattern_info['severity'],
                            description=pattern_info['description'],
                            affected_components=[vuln_type],
                            exploit_risk=0.7 if pattern_info['severity'] == 'HIGH' else 0.4,
                            mitigation=f"修复{pattern_info['description']}相关代码"
                        ))
                        break  # 每种类型只报告一次
            
        except Exception as e:
            self.logger.error(f"代码漏洞扫描失败 {app_package}: {e}")
        
        return vulnerabilities
    
    def _scan_permission_abuse(self, app_package: str, permissions: List[str]) -> List[AppVulnerability]:
        """扫描权限滥用"""
        vulnerabilities = []
        
        try:
            # 检查高风险权限
            high_risk_perms = []
            for perm in permissions:
                if perm in self.permission_risks:
                    risk_info = self.permission_risks[perm]
                    if risk_info['risk_level'] > 0.7:
                        high_risk_perms.append((perm, risk_info))
            
            if len(high_risk_perms) > 2:
                # 多个高风险权限组合
                perm_names = [perm for perm, _ in high_risk_perms]
                vulnerabilities.append(AppVulnerability(
                    app_package=app_package,
                    vuln_type='permission_abuse',
                    severity='HIGH',
                    description=f"应用请求过多高风险权限: {', '.join(perm_names[:3])}等",
                    affected_components=['permissions'],
                    exploit_risk=0.8,
                    mitigation="审核权限使用合理性，移除不必要的权限"
                ))
            
            # 检查特殊权限组合
            self._check_permission_combinations(app_package, permissions, vulnerabilities)
            
        except Exception as e:
            self.logger.error(f"权限滥用扫描失败 {app_package}: {e}")
        
        return vulnerabilities
    
    def _check_permission_combinations(self, app_package: str, permissions: List[str], 
                                     vulnerabilities: List[AppVulnerability]):
        """检查危险权限组合"""
        perm_set = set(permissions)
        
        # 银行木马模式
        banking_perms = {'SYSTEM_ALERT_WINDOW', 'CALL_PHONE', 'SEND_SMS'}
        if banking_perms.issubset(set(p.split('.')[-1] for p in permissions)):
            vulnerabilities.append(AppVulnerability(
                app_package=app_package,
                vuln_type='banking_trojan_pattern',
                severity='CRITICAL',
                description="检测到银行木马典型权限组合",
                affected_components=['permissions'],
                exploit_risk=0.9,
                mitigation="高度可疑应用，建议立即卸载"
            ))
        
        # 间谍软件模式  
        spy_perms = {'RECORD_AUDIO', 'ACCESS_FINE_LOCATION', 'CAMERA', 'READ_SMS'}
        spy_count = len([p for p in permissions if any(sp in p for sp in spy_perms)])
        if spy_count >= 3:
            vulnerabilities.append(AppVulnerability(
                app_package=app_package,
                vuln_type='spyware_pattern', 
                severity='HIGH',
                description="检测到间谍软件典型权限组合",
                affected_components=['permissions'],
                exploit_risk=0.8,
                mitigation="可能的间谍软件，建议审查应用功能"
            ))
    
    def _scan_component_vulnerabilities(self, app_package: str, app_info: Dict[str, Any]) -> List[AppVulnerability]:
        """扫描组件配置漏洞"""
        vulnerabilities = []
        
        try:
            package_info = app_info.get('package_info', '')
            
            # 检查导出组件
            if 'exported=true' in package_info:
                exported_count = package_info.count('exported=true')
                if exported_count > 5:
                    vulnerabilities.append(AppVulnerability(
                        app_package=app_package,
                        vuln_type='excessive_exported_components',
                        severity='MEDIUM',
                        description=f"过多导出组件({exported_count}个)，可能存在攻击面",
                        affected_components=['components'],
                        exploit_risk=0.5,
                        mitigation="减少不必要的导出组件，加强Intent过滤"
                    ))
            
            # 检查调试模式
            if 'debuggable=true' in package_info:
                vulnerabilities.append(AppVulnerability(
                    app_package=app_package,
                    vuln_type='debug_enabled',
                    severity='MEDIUM',
                    description="应用启用了调试模式",
                    affected_components=['application'],
                    exploit_risk=0.4,
                    mitigation="在生产版本中禁用调试模式"
                ))
            
            # 检查备份允许
            if 'allowBackup=true' in package_info:
                vulnerabilities.append(AppVulnerability(
                    app_package=app_package,
                    vuln_type='backup_allowed',
                    severity='LOW',
                    description="应用允许数据备份，可能泄露敏感数据",
                    affected_components=['application'],
                    exploit_risk=0.3,
                    mitigation="禁用应用数据备份或加密敏感数据"
                ))
            
        except Exception as e:
            self.logger.error(f"组件漏洞扫描失败 {app_package}: {e}")
        
        return vulnerabilities


class ConfigurationSecurityAssessor(LoggerMixin):
    """配置安全评估器"""
    
    def __init__(self, device_manager: DeviceManager):
        self.device_manager = device_manager
        self.security_configurations = self._load_security_configurations()
        
    def _load_security_configurations(self) -> Dict[str, Any]:
        """加载安全配置检查项"""
        return {
            'system_security': [
                {
                    'name': 'screen_lock',
                    'description': '屏幕锁定安全',
                    'check_method': 'lockscreen_security',
                    'severity': 'HIGH'
                },
                {
                    'name': 'auto_update',
                    'description': '自动更新设置',
                    'check_method': 'auto_update_config',
                    'severity': 'MEDIUM'
                },
                {
                    'name': 'usb_debugging',
                    'description': 'USB调试状态',
                    'check_method': 'usb_debug_status',
                    'severity': 'MEDIUM'
                }
            ],
            'app_security': [
                {
                    'name': 'unknown_sources',
                    'description': '未知来源安装',
                    'check_method': 'unknown_sources_check',
                    'severity': 'HIGH'
                },
                {
                    'name': 'app_verification',
                    'description': '应用验证设置',
                    'check_method': 'app_verification_check',
                    'severity': 'MEDIUM'
                },
                {
                    'name': 'install_from_unknown',
                    'description': '允许从未知应用安装',
                    'check_method': 'install_unknown_apps',
                    'severity': 'MEDIUM'
                }
            ],
            'network_security': [
                {
                    'name': 'wifi_security',
                    'description': 'WiFi安全配置',
                    'check_method': 'wifi_security_check',
                    'severity': 'MEDIUM'
                },
                {
                    'name': 'tethering',
                    'description': '热点共享设置',
                    'check_method': 'tethering_check',
                    'severity': 'LOW'
                }
            ]
        }
    
    def assess_device_configuration(self, device_id: str) -> List[ConfigurationIssue]:
        """评估设备配置安全"""
        issues = []
        
        try:
            # 检查系统安全配置
            for config in self.security_configurations['system_security']:
                issue = self._check_configuration(device_id, config)
                if issue:
                    issues.append(issue)
            
            # 检查应用安全配置  
            for config in self.security_configurations['app_security']:
                issue = self._check_configuration(device_id, config)
                if issue:
                    issues.append(issue)
            
            # 检查网络安全配置
            for config in self.security_configurations['network_security']:
                issue = self._check_configuration(device_id, config)
                if issue:
                    issues.append(issue)
            
        except Exception as e:
            self.logger.error(f"配置安全评估失败: {e}")
        
        return issues
    
    def _check_configuration(self, device_id: str, config: Dict[str, Any]) -> Optional[ConfigurationIssue]:
        """检查单个配置项"""
        try:
            method_name = config['check_method']
            check_method = getattr(self, f"_{method_name}", None)
            
            if check_method:
                result = check_method(device_id)
                if result and result.get('has_issue', False):
                    return ConfigurationIssue(
                        category=config.get('category', 'system'),
                        issue_type=config['name'],
                        severity=config['severity'],
                        description=result['description'],
                        current_value=result.get('current_value', 'unknown'),
                        recommended_value=result.get('recommended_value', 'secure'),
                        risk_level=result.get('risk_level', 0.5),
                        auto_fixable=result.get('auto_fixable', False)
                    )
            
            return None
            
        except Exception as e:
            self.logger.error(f"配置检查失败 {config['name']}: {e}")
            return None
    
    def _lockscreen_security(self, device_id: str) -> Dict[str, Any]:
        """检查锁屏安全"""
        try:
            # 检查锁屏类型
            result = self.device_manager.execute_command(device_id, "dumpsys device_policy | grep PasswordQuality")
            
            if not result or 'UNSPECIFIED' in result:
                return {
                    'has_issue': True,
                    'description': '未设置屏幕锁定或使用了不安全的锁定方式',
                    'current_value': '无锁定或不安全锁定',
                    'recommended_value': '密码或指纹锁定',
                    'risk_level': 0.8,
                    'auto_fixable': False
                }
            
            return {'has_issue': False}
            
        except Exception as e:
            self.logger.error(f"锁屏安全检查失败: {e}")
            return {'has_issue': False}
    
    def _auto_update_config(self, device_id: str) -> Dict[str, Any]:
        """检查自动更新配置"""
        try:
            result = self.device_manager.execute_command(device_id, "settings get global auto_update_system")
            
            if result and result.strip() == '0':
                return {
                    'has_issue': True,
                    'description': '系统自动更新已禁用，可能错过重要安全补丁',
                    'current_value': '禁用',
                    'recommended_value': '启用',
                    'risk_level': 0.6,
                    'auto_fixable': True
                }
            
            return {'has_issue': False}
            
        except:
            return {'has_issue': False}
    
    def _usb_debug_status(self, device_id: str) -> Dict[str, Any]:
        """检查USB调试状态"""
        try:
            result = self.device_manager.execute_command(device_id, "getprop service.adb.root")
            
            if result and result.strip() == '1':
                return {
                    'has_issue': True,
                    'description': 'USB调试已启用，存在安全风险',
                    'current_value': '启用',
                    'recommended_value': '禁用',
                    'risk_level': 0.5,
                    'auto_fixable': True
                }
            
            return {'has_issue': False}
            
        except:
            return {'has_issue': False}
    
    def _unknown_sources_check(self, device_id: str) -> Dict[str, Any]:
        """检查未知来源安装"""
        try:
            result = self.device_manager.execute_command(device_id, "settings get global install_non_market_apps")
            
            if result and result.strip() == '1':
                return {
                    'has_issue': True,
                    'description': '允许安装未知来源应用，存在恶意软件风险',
                    'current_value': '允许',
                    'recommended_value': '禁止',
                    'risk_level': 0.8,
                    'auto_fixable': True
                }
            
            return {'has_issue': False}
            
        except:
            return {'has_issue': False}
    
    def _app_verification_check(self, device_id: str) -> Dict[str, Any]:
        """检查应用验证设置"""
        try:
            result = self.device_manager.execute_command(device_id, "settings get global package_verifier_enable")
            
            if result and result.strip() == '0':
                return {
                    'has_issue': True,
                    'description': '应用验证已禁用，无法检测有害应用',
                    'current_value': '禁用',
                    'recommended_value': '启用',
                    'risk_level': 0.7,
                    'auto_fixable': True
                }
            
            return {'has_issue': False}
            
        except:
            return {'has_issue': False}
    
    def _install_unknown_apps(self, device_id: str) -> Dict[str, Any]:
        """检查从未知应用安装设置"""
        try:
            # Android 8.0+的检查方式
            result = self.device_manager.execute_command(device_id, "dumpsys package | grep INSTALL_NON_MARKET_APPS")
            
            if result and 'granted=true' in result:
                return {
                    'has_issue': True,
                    'description': '某些应用被允许安装其他应用',
                    'current_value': '部分允许',
                    'recommended_value': '严格限制',
                    'risk_level': 0.6,
                    'auto_fixable': False
                }
            
            return {'has_issue': False}
            
        except:
            return {'has_issue': False}
    
    def _wifi_security_check(self, device_id: str) -> Dict[str, Any]:
        """检查WiFi安全配置"""
        try:
            result = self.device_manager.execute_command(device_id, "dumpsys wifi")
            
            if result and ('WEP' in result or 'NONE' in result):
                return {
                    'has_issue': True,
                    'description': '连接到不安全的WiFi网络',
                    'current_value': '不安全加密',
                    'recommended_value': 'WPA2/WPA3',
                    'risk_level': 0.5,
                    'auto_fixable': False
                }
            
            return {'has_issue': False}
            
        except:
            return {'has_issue': False}
    
    def _tethering_check(self, device_id: str) -> Dict[str, Any]:
        """检查热点共享设置"""
        try:
            result = self.device_manager.execute_command(device_id, "dumpsys connectivity tethering")
            
            if result and 'TetherState:TETHERED' in result:
                return {
                    'has_issue': True,
                    'description': '热点共享已启用，可能存在安全风险',
                    'current_value': '启用',
                    'recommended_value': '按需启用',
                    'risk_level': 0.3,
                    'auto_fixable': False
                }
            
            return {'has_issue': False}
            
        except:
            return {'has_issue': False}